<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!--===================================================================================-->
  <style type="text/css">
    * {
      box-sizing: border-box;
    }

    body {
      font-family: Arial, Helvetica, sans-serif;
    }

    #chatlog {
      position: fixed;
      top: 0;
      bottom: 32px;
      left: 0;
      right: 200px;
      overflow-y: auto;
      padding: 8px;
      overflow-wrap: break-word;
      transition: right 0.3s ease, bottom 0.1s ease;
    }

    #chatlog.thread-open {
      right: 600px;
    }

    #chatlog span.username {
      font-weight: bold;
    }

    #spacer {
      height: calc(100vh - 32px - 5em);
    }

    #right-sidebar {
      position: fixed;
      right: 0;
      top: 0;
      bottom: 32px;
      width: 200px;
      display: flex;
      flex-direction: column;
      border-left: 1px solid #ddd;
      background: white;
      transition: bottom 0.1s ease;
    }

    #room-info {
      flex-shrink: 0;
      border-bottom: 1px solid #ddd;
      background: #fafafa;
      padding: 8px;
      font-size: 0.9em;
    }

    #room-info h3 {
      margin: 0 0 8px 0;
      font-size: 1em;
      color: #333;
    }

    #room-name-display {
      font-weight: bold;
      color: #1da1f2;
      margin-bottom: 12px;
      word-break: break-all;
      cursor: pointer;
      padding: 4px;
      border-radius: 3px;
      transition: background-color 0.2s;
    }

    #room-name-display:hover {
      background-color: #f0f8ff;
    }

    #room-name-input {
      width: 100%;
      font-weight: bold;
      color: #1da1f2;
      padding: 4px;
      border: 1px solid #1da1f2;
      border-radius: 3px;
      font-family: Arial, sans-serif;
      font-size: 0.9em;
      margin-bottom: 12px;
      display: none;
    }

    #room-name-input:focus {
      outline: none;
      border-color: #0d8dd9;
    }

    #room-description-label {
      color: #666;
      font-size: 0.85em;
      margin-bottom: 4px;
      cursor: pointer;
      padding: 2px;
      border-radius: 3px;
      transition: background-color 0.2s;
    }

    #room-description-label:hover {
      background-color: #f0f8ff;
    }

    #room-note {
      width: 100%;
      min-height: 60px;
      padding: 6px;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-family: Arial, sans-serif;
      font-size: 0.9em;
      resize: vertical;
      background: white;
      display: none;
      margin-top: 4px;
    }

    #room-note:focus {
      outline: none;
      border-color: #1da1f2;
    }

    #room-note.visible {
      display: block;
    }

    #roster-container {
      font-weight: bold;
      padding: 8px;
      flex: 1;
      overflow-y: auto;
      background: white;
    }

    #roster-container h3 {
      margin: 0 0 8px 0;
      font-size: 1em;
      color: #333;
    }

    #roster .user-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    #roster .logout-btn {
      background: transparent;
      color: #999;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 1px 6px;
      cursor: pointer;
      font-size: 11px;
      margin-left: 8px;
    }

    #roster .logout-btn:hover {
      background: #f5f5f5;
      color: #666;
      border-color: #ccc;
    }

    p {
      margin-top: 0;
      margin-bottom: 8px;
    }

    p:last-of-type {
      margin: 0;
    }

    #roster {
      flex: 1;
      overflow-y: auto;
      background: white;
    }

    ::-webkit-scrollbar {
      display: none;
    }

    @media(max-width:600px) {
      #right-sidebar {
        display: none;
      }

      #thread-panel {
        display: none !important;
      }

      #chatlog {
        right: 0;
      }
    }

    #reply-indicator {
      position: fixed;
      left: 0;
      bottom: 45px;
      width: 100%;
      background: #f0f7ff;
      border-top: 1px solid #1da1f2;
      padding: 8px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.9em;
      color: #666;
      z-index: 100;
    }

    #reply-indicator .reply-indicator-text {
      flex: 1;
      font-style: italic;
    }

    #reply-indicator .reply-indicator-close {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.2em;
      color: #999;
      padding: 0 8px;
    }

    #reply-indicator .reply-indicator-close:hover {
      color: #333;
    }

    #chat-input {
      position: fixed;
      width: calc(100% - 40px);
      min-height: 32px;
      max-height: 150px;
      bottom: 0;
      left: 0;
      border: none;
      border-top: none;
      padding-left: 32px;
      padding-top: 8px;
      padding-bottom: 8px;
      padding-right: 8px;
      outline: none;
      resize: none;
      overflow-y: auto;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 16px;
      line-height: 1.2;
    }

    #file-upload-btn {
      position: fixed;
      width: 40px;
      min-height: 32px;
      bottom: 0;
      right: 0;
      border: none;
      background: #f0f0f0;
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #file-upload-btn:hover {
      background: #e0e0e0;
    }

    #file-input {
      display: none;
    }

    #chatroom::before {
      z-index: 1;
      display: block;
      content: ">";
      position: fixed;
      bottom: 0;
      left: 0;
      width: 32px;
      height: 32px;
      line-height: 32px;
      text-align: center;
      font-weight: bold;
      color: #888;
      -webkit-text-stroke-width: 2px;
    }

    #name-form {
      position: fixed;
      z-index: 3;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: white;
    }

    #name-input {
      position: fixed;
      font-size: 200%;
      top: calc(50% - 1em);
      left: calc(50% - 8em);
      width: 16em;
      height: 2em;
      margin: 0;
      text-align: center;
      border: 1px solid #bbb;
    }

    #name-form p {
      position: fixed;
      top: calc(50% + 3em);
      width: 100%;
      text-align: center;
    }

    #room-form {
      position: fixed;
      z-index: 2;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: white;
      font-size: 200%;
      margin-top: calc(50vh - 3em);
      text-align: center;
    }

    #room-name {
      font-size: inherit;
      border: 1px solid #bbb;
      height: 2em;
      width: 16em;
      padding-left: 1em;
    }

    #room-form button {
      font-size: inherit;
      border: 1px solid #bbb;
      background-color: #eee;
      height: 2em;
    }

    @media(max-width:660px) {

      #name-input,
      #room-form {
        font-size: 150%;
      }

      #name-form p {
        font-size: 75%;
      }
    }

    @media(max-width:500px) {

      #name-input,
      #room-form {
        font-size: 100%;
      }

      #name-form p {
        font-size: 50%;
      }
    }

    #go-public {
      width: 4em;
    }

    #go-private {
      width: 20em;
    }

    #room-history {
      margin-top: 2em;
      font-size: 0.6em;
    }

    #room-history h3 {
      margin: 0 0 0.5em 0;
      color: #666;
    }

    #room-history-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5em;
      justify-content: center;
      max-width: 600px;
      margin: 0 auto;
    }

    .room-history-item {
      background: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 0.5em 1em;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5em;
    }

    .room-history-item:hover {
      background: #e0e0e0;
      border-color: #ccc;
    }

    .room-history-item .room-name {
      font-weight: bold;
    }

    .room-history-item .remove-btn {
      background: transparent;
      border: none;
      color: #999;
      cursor: pointer;
      font-size: 1.2em;
      padding: 0 0.2em;
      line-height: 1;
    }

    .room-history-item .remove-btn:hover {
      color: #f00;
    }

    /* Hashtag styles */
    a.hashtag {
      color: #1da1f2;
      font-weight: 500;
      text-decoration: none;
      cursor: pointer;
      padding: 0 2px;
      border-radius: 2px;
      transition: background-color 0.2s;
    }

    a.hashtag:hover {
      background-color: #e8f5fd;
      text-decoration: underline;
    }

    #hashtag-panel {
      position: fixed;
      right: 0;
      top: 0;
      bottom: 32px;
      width: 200px;
      border-left: 1px solid #ddd;
      background: #fafafa;
      overflow-y: auto;
      padding: 8px;
      font-size: 0.9em;
      transition: bottom 0.1s ease;
      display: none;
      z-index: 100;
    }

    #hashtag-panel.visible {
      display: block;
    }

    #hashtag-panel h3 {
      margin: 0 0 12px 0;
      font-size: 1em;
      color: #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #hashtag-toggle {
      position: fixed;
      right: 0;
      bottom: 32px;
      width: 40px;
      height: 32px;
      background: #f0f0f0;
      border: none;
      border-top: 1px solid #ddd;
      border-left: 1px solid #ddd;
      cursor: pointer;
      font-size: 18px;
      z-index: 101;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #hashtag-toggle:hover {
      background: #e0e0e0;
    }

    #hashtag-toggle .hashtag-close {
      display: none;
    }

    /* When hashtag panel is open, change the toggle button appearance */
    body:has(#hashtag-panel.visible) #hashtag-toggle {
      color: black;
    }

    body:has(#hashtag-panel.visible) #hashtag-toggle .hashtag-icon {
      display: none;
    }

    body:has(#hashtag-panel.visible) #hashtag-toggle .hashtag-close {
      display: block;
    }

    .hashtag-item {
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 6px 8px;
      margin-bottom: 6px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .hashtag-item:hover {
      background: #f0f8ff;
      border-color: #1da1f2;
    }

    .hashtag-item.active {
      background: #e8f5fd;
      border-color: #1da1f2;
      font-weight: bold;
    }

    .hashtag-name {
      color: #1da1f2;
      font-weight: 500;
    }

    .hashtag-count {
      color: #999;
      font-size: 0.85em;
    }

    #hashtag-filter-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 200px;
      background: #fff3cd;
      border-bottom: 1px solid #ffc107;
      padding: 8px 16px;
      display: none;
      align-items: center;
      justify-content: space-between;
      z-index: 5;
    }

    #hashtag-filter-banner.visible {
      display: flex;
    }

    #hashtag-filter-banner+#chatlog {
      top: 41px;
    }

    .filter-clear-btn {
      background: #ffc107;
      color: #333;
      border: none;
      border-radius: 3px;
      padding: 4px 12px;
      cursor: pointer;
      font-size: 0.9em;
    }

    .filter-clear-btn:hover {
      background: #ffb300;
    }

    /* Thread Panel Styles */
    #thread-panel {
      position: fixed;
      right: 200px;
      top: 0;
      bottom: 32px;
      width: 400px;
      background: white;
      border-left: 1px solid #ddd;
      display: none;
      flex-direction: column;
      z-index: 50;
      transition: bottom 0.1s ease;
    }

    #thread-panel.visible {
      display: flex;
    }

    #thread-header {
      padding: 12px 16px;
      border-bottom: 2px solid #ddd;
      background: #fafafa;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    #thread-header h3 {
      margin: 0;
      font-size: 1em;
      color: #333;
    }

    #thread-close {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #666;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #thread-close:hover {
      color: #000;
      background: #e0e0e0;
      border-radius: 3px;
    }

    #thread-original-message {
      padding: 12px 16px;
      border-bottom: 1px solid #eee;
      background: #f9f9f9;
      flex-shrink: 0;
    }

    #thread-replies {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    #thread-input-container {
      border-top: 1px solid #ddd;
      padding: 8px;
      flex-shrink: 0;
    }

    #thread-input {
      width: 100%;
      min-height: 60px;
      max-height: 120px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: vertical;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 14px;
      outline: none;
    }

    #thread-input:focus {
      border-color: #1da1f2;
    }

    /* Message Actions */
    .message-wrapper {
      position: relative;
      padding: 4px 0;
      margin: 4px 0;
      border-radius: 4px;
    }

    .message-wrapper:hover {
      background: #f8f8f8;
    }

    .message-wrapper:hover .message-actions {
      display: flex;
    }

    .message-actions {
      position: absolute;
      right: 8px;
      top: 4px;
      display: none;
      gap: 4px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 2px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .message-action-btn {
      background: none;
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 14px;
      border-radius: 3px;
      display: flex;
      align-items: center;
      gap: 4px;
      color: #666;
    }

    .message-action-btn:hover {
      background: #f0f0f0;
      color: #000;
    }

    .thread-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.85em;
      color: #1da1f2;
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 3px;
      margin-top: 4px;
    }

    .thread-indicator:hover {
      background: #e8f5fd;
      text-decoration: underline;
    }

    .reply-reference {
      background: #f5f5f5;
      border-left: 3px solid #1da1f2;
      padding: 4px 10px;
      margin: 4px 0 8px 0;
      border-radius: 3px;
      font-size: 0.85em;
      color: #666;
      cursor: pointer;
      font-style: italic;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .reply-reference:hover {
      background: #ebebeb;
    }

    .reply-reference .reply-icon {
      color: #1da1f2;
      font-style: normal;
      flex-shrink: 0;
      line-height: 1;
      display: flex;
      align-items: center;
    }

    .reply-reference .reply-author {
      font-weight: 600;
      color: #1da1f2;
      font-style: normal;
      flex-shrink: 0;
    }

    .reply-reference .reply-separator {
      font-style: normal;
      flex-shrink: 0;
    }

    .reply-reference .reply-preview {
      color: #555;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
      min-width: 0;
    }

    @media(max-width:600px) {
      #hashtag-panel {
        display: none !important;
      }

      #hashtag-toggle {
        display: none;
      }

      #chatlog {
        right: 0;
      }

      #hashtag-filter-banner {
        right: 0;
      }
    }
  </style>

</head>

<body>
  <form id="name-form" action="/fake-form-action">
    <input id="name-input" placeholder="your name">
    <p>This chat runs entirely on the edge, powered by<br>
      <a href="https://blog.cloudflare.com/introducing-workers-durable-objects" target="_blank">Cloudflare Workers
        Durable Objects</a>
    </p>
  </form>
  <form id="room-form" action="/fake-form-action">
    <p>Enter a public room:</p>
    <input id="room-name" placeholder="room name"><button id="go-public">Go &raquo;</button>
    <p>OR</p>
    <button id="go-private">Create a Private Room &raquo;</button>
    <div id="room-history">
      <h3>Recent Rooms</h3>
      <div id="room-history-list"></div>
    </div>
  </form>
  <div id="hashtag-filter-banner">
    <span>Filtering by: <strong id="active-hashtag"></strong></span>
    <button class="filter-clear-btn" onclick="clearHashtagFilter()">Clear Filter ✕</button>
  </div>
  <div id="hashtag-panel">
    <h3>
      <span>📌 Hashtags</span>
    </h3>
    <div id="hashtag-list"></div>
  </div>
  <div id="thread-panel">
    <div id="thread-header">
      <h3>💬 Thread</h3>
      <button id="thread-close" title="Close thread">✕</button>
    </div>
    <div id="thread-original-message"></div>
    <div id="thread-replies"></div>
    <div id="thread-input-container">
      <textarea id="thread-input" placeholder="Reply in thread..." rows="3"></textarea>
    </div>
  </div>
  <form id="chatroom" action="/fake-form-action">
    <div id="chatlog">
      <div id="spacer"></div>
    </div>
    <div id="right-sidebar">
      <div id="room-info">
        <h3>🏠 Room Info</h3>
        <div id="room-name-container">
          <div id="room-name-display"></div>
          <input type="text" id="room-name-input" />
        </div>
        <div id="room-description-container">
          <div id="room-description-label">📝 Description (click to edit)</div>
          <textarea id="room-note" placeholder="Add room description..."></textarea>
        </div>
      </div>
      <div id="roster-container">
        <h3>👥 Online Members</h3>
        <div id="roster">
        </div>
      </div>

    </div>
    <div id="reply-indicator" style="display:none;">
      <button type="button" class="reply-indicator-close">✕</button>
      <span class="reply-indicator-text"></span>
    </div>
    <textarea id="chat-input" rows="1" placeholder="Type a message..."></textarea>
    <input type="file" id="file-input" accept="image/*,application/pdf,.doc,.docx,.txt">
    <button type="button" id="file-upload-btn" title="Upload file">📎</button>
    <button type="button" id="hashtag-toggle" title="Toggle hashtags">
      <span class="hashtag-icon">#</span>
      <span class="hashtag-close">✕</span>
    </button>
  </form>
</body>
<script type="text/javascript">
  function createReactiveState(initialState) {
    const listeners = new Set();

    const proxy = new Proxy(initialState, {
      get(target, property, receiver) {
        return Reflect.get(target, property, receiver)
      },

      set(target, property, value, receiver) {
        const oldValue = target[property];
        const success = Reflect.set(target, property, value, receiver)
        if (success && oldValue !== value) {
          listeners.forEach(listener => listener(property, value, oldValue))
        }
      }
    })

    return {
      state: proxy,
      subscribe(listener) {
        listeners.add(listener);
        return () => listeners.delete(listener)
      }
    }
  }
  // System message custom element
  class SystemMessage extends HTMLElement {
    connectedCallback() {
      this.render();
    }
    render() {
      const message = this.getAttribute('message');
      this.innerHTML = '';
      const sysSpan = document.createElement('span');
      sysSpan.className = 'system-message';
      sysSpan.textContent = message;
      sysSpan.style.color = '#888';
      sysSpan.style.fontStyle = 'italic';
      this.appendChild(sysSpan);
    }
  }
  customElements.define('system-message', SystemMessage);

  // Define custom element for chat messages
  class ChatMessage extends HTMLElement {
    connectedCallback() {
      this.render();
    }

    render() {
      const username = this.getAttribute('username');
      const message = this.getAttribute('message');
      const timestamp = this.getAttribute('timestamp');
      const messageId = this.getAttribute('message-id');
      const replyTo = this.getAttribute('reply-to');
      const threadCount = this.getAttribute('thread-count') || '0';
      const isInThread = this.getAttribute('is-in-thread') === 'true';

      // Clear existing content
      this.innerHTML = '';

      // Add reply reference if this is a reply and not in thread view
      if (replyTo && !isInThread) {
        try {
          const replyData = JSON.parse(replyTo);
          const replyRef = document.createElement('div');
          replyRef.className = 'reply-reference';
          replyRef.innerHTML = `
            <span class="reply-icon">↩</span>
            <span class="reply-author">${replyData.username}</span>
            <span class="reply-separator">:</span>
            <span class="reply-preview">${replyData.preview}</span>
          `;
          replyRef.onclick = () => {
            // Scroll to and highlight the original message
            const originalMsg = document.querySelector(`[data-message-id="${replyData.messageId}"]`);
            if (originalMsg) {
              originalMsg.scrollIntoView({ behavior: 'smooth', block: 'center' });
              originalMsg.style.background = '#fff3cd';
              setTimeout(() => {
                originalMsg.style.background = '';
              }, 2000);
            }
            // Open the thread for the referenced message
            window.openThread(replyData.messageId);
          };
          this.appendChild(replyRef);
        } catch (e) {
          console.error('Failed to parse replyTo:', e);
        }
      }

      // Add time if present
      if (timestamp) {
        const date = new Date(Number(timestamp));
        const hh = String(date.getHours()).padStart(2, '0');
        const mm = String(date.getMinutes()).padStart(2, '0');
        const ss = String(date.getSeconds()).padStart(2, '0');
        const timeSpan = document.createElement('span');
        timeSpan.className = 'msg-time';
        timeSpan.textContent = `[${hh}:${mm}:${ss}] `;
        timeSpan.style.color = '#888';
        timeSpan.style.fontSize = '0.95em';
        this.appendChild(timeSpan);
      }

      // Add username if present
      if (username) {
        const usernameSpan = document.createElement('span');
        usernameSpan.className = 'username';
        usernameSpan.textContent = username + ': ';
        this.appendChild(usernameSpan);
      }

      // Handle file messages (check inside the element)
      if (message.startsWith("FILE:")) {
        this.renderFileMessage(message);
      } else {
        // Handle regular text messages with link detection
        this.renderTextMessage(message);
      }

      // Add thread indicator if there are replies
      if (parseInt(threadCount) > 0) {
        const threadIndicator = document.createElement('div');
        threadIndicator.className = 'thread-indicator';
        threadIndicator.innerHTML = `💬 ${threadCount} ${parseInt(threadCount) === 1 ? 'reply' : 'replies'}`;
        threadIndicator.onclick = (e) => {
          e.stopPropagation();
          if (messageId) {
            window.openThread(messageId);
          }
        };
        this.appendChild(document.createElement('br'));
        this.appendChild(threadIndicator);
      }
    }

    renderFileMessage(message) {
      const parts = message.substring(5).split("|");
      const fileUrl = parts[0];
      const fileName = parts[1] || "file";
      const fileType = parts[2] || "";

      // If it's an image, display it inline
      if (fileType.startsWith("image/")) {
        const img = document.createElement("img");
        img.src = fileUrl;
        img.alt = fileName;
        img.style.maxWidth = "300px";
        img.style.maxHeight = "300px";
        img.style.display = "block";
        img.style.marginTop = "5px";
        img.style.cursor = "pointer";
        img.onclick = () => window.open(fileUrl, "_blank");
        this.appendChild(img);

        const link = document.createElement("a");
        link.href = fileUrl;
        link.target = "_blank";
        link.textContent = fileName;
        link.style.fontSize = "0.9em";
        this.appendChild(document.createElement("br"));
        this.appendChild(link);
      } else {
        // For other files, just show a download link
        const link = document.createElement("a");
        link.href = fileUrl;
        link.download = fileName;
        link.target = "_blank";
        link.textContent = "📎 " + fileName;
        this.appendChild(link);
      }
    }

    renderTextMessage(text) {
      // Combined regex pattern - matches URLs and hashtags
      // URLs: http://, https://, and www. URLs
      // Hashtags: #word (2-32 chars, alphanumeric, underscore, Chinese)
      const combinedRegex = /(https?:\/\/[^\s]+)|(www\.[^\s]+)|(#[a-zA-Z0-9_\u4e00-\u9fa5]{2,32})/g;

      let lastIndex = 0;
      let match;

      // Find all URLs and hashtags in the text
      while ((match = combinedRegex.exec(text)) !== null) {
        // Add text before the match
        if (match.index > lastIndex) {
          const textNode = document.createTextNode(text.substring(lastIndex, match.index));
          this.appendChild(textNode);
        }

        if (match[3]) {
          // It's a hashtag
          const hashtag = match[3];
          const link = document.createElement('a');
          link.className = 'hashtag';
          link.href = '#';
          link.textContent = hashtag;
          link.dataset.tag = hashtag.substring(1); // Remove the # prefix
          link.onclick = (e) => {
            e.preventDefault();
            window.filterByHashtag(link.dataset.tag);
          };
          this.appendChild(link);
        } else {
          // It's a URL
          const link = document.createElement('a');
          let url = match[0];

          // Add https:// if it's a www. link
          if (url.startsWith('www.')) {
            link.href = 'https://' + url;
          } else {
            link.href = url;
          }

          link.target = '_blank';
          link.rel = 'noopener noreferrer';
          link.textContent = url;
          link.style.color = '#0066cc';
          link.style.textDecoration = 'underline';
          this.appendChild(link);
        }

        lastIndex = combinedRegex.lastIndex;
      }

      // Add remaining text after last match (or all text if no matches found)
      if (lastIndex < text.length) {
        const textNode = document.createTextNode(text.substring(lastIndex));
        this.appendChild(textNode);
      }
    }
  }

  // Register the custom element
  customElements.define('chat-message', ChatMessage);

  let currentWebSocket = null;

  let nameForm = document.querySelector("#name-form");
  let nameInput = document.querySelector("#name-input");
  let roomForm = document.querySelector("#room-form");
  let roomNameInput = document.querySelector("#room-name");
  let goPublicButton = document.querySelector("#go-public");
  let goPrivateButton = document.querySelector("#go-private");
  let chatroom = document.querySelector("#chatroom");
  let chatlog = document.querySelector("#chatlog");
  let chatInput = document.querySelector("#chat-input");
  let roster = document.querySelector("#roster");
  let fileInput = document.querySelector("#file-input");
  let fileUploadBtn = document.querySelector("#file-upload-btn");
  let hashtagPanel = document.querySelector("#hashtag-panel");
  let hashtagToggle = document.querySelector("#hashtag-toggle");
  let hashtagList = document.querySelector("#hashtag-list");
  let hashtagFilterBanner = document.querySelector("#hashtag-filter-banner");
  let activeHashtagSpan = document.querySelector("#active-hashtag");

  // Thread panel elements
  let threadPanel = document.querySelector("#thread-panel");
  let threadClose = document.querySelector("#thread-close");
  let threadOriginalMessage = document.querySelector("#thread-original-message");
  let threadReplies = document.querySelector("#thread-replies");
  let threadInput = document.querySelector("#thread-input");

  // Reply indicator elements
  let replyIndicator = document.querySelector("#reply-indicator");
  let replyIndicatorClose = replyIndicator.querySelector(".reply-indicator-close");

  // Is the chatlog scrolled to the bottom?
  let isAtBottom = true;

  let username;
  let roomname;
  let currentHashtagFilter = null; // Current active hashtag filter
  let allHashtags = []; // Cache of all hashtags

  // Thread state
  let currentThreadId = null;  // Currently open thread
  let messagesCache = new Map();  // messageId -> message data
  let threadsCache = new Map();   // messageId -> array of reply messages

  // Reply state for main chat input
  let currentReplyTo = null;  // {messageId, username, preview, rootMessageId}

  // Generate UUID v4 using crypto.randomUUID or fallback
  function generateUUID() {
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    // Fallback for older browsers
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  // Generate message ID from timestamp and username for legacy messages
  function generateLegacyMessageId(timestamp, username) {
    return `${timestamp}-${username}`;
  }

  let hostname = window.location.host;
  if (hostname == "") {
    // Probably testing the HTML locally.
    hostname = "edge-chat-demo.cloudflareworkers.com";
  }

  // API Client class for server requests
  class ChatAPI {
    constructor(hostname) {
      this.hostname = hostname;
      this.baseUrl = `https://${hostname}/api`;
    }

    // Create private room
    async createPrivateRoom() {
      const response = await fetch(`${this.baseUrl}/room`, { method: "POST" });
      if (!response.ok) {
        throw new Error('Failed to create private room');
      }
      return await response.text();
    }

    // Get hashtags for a room
    async getHashtags(roomName) {
      const response = await fetch(`${this.baseUrl}/room/${roomName}/hashtags`);
      if (!response.ok) {
        throw new Error('Failed to load hashtags');
      }
      return await response.json();
    }

    // Get room info
    async getRoomInfo(roomName) {
      const response = await fetch(`${this.baseUrl}/room/${roomName}/info`);
      if (!response.ok) {
        throw new Error('Failed to load room info');
      }
      return await response.json();
    }

    // Update room info
    async updateRoomInfo(roomName, data) {
      const response = await fetch(`${this.baseUrl}/room/${roomName}/info`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      });
      if (!response.ok) {
        throw new Error('Failed to save room info');
      }
      return await response.json();
    }

    // Upload file
    async uploadFile(roomName, formData) {
      const response = await fetch(`${this.baseUrl}/room/${roomName}/upload`, {
        method: "POST",
        body: formData
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || "Upload failed");
      }
      return await response.json();
    }

    // Get WebSocket URL
    getWebSocketUrl(roomName) {
      const wss = window.location.protocol === "http:" ? "ws://" : "wss://";
      return `${wss}${this.hostname}/api/room/${roomName}/websocket`;
    }
  }

  // Initialize API client
  const api = new ChatAPI(hostname);

  // Thread functions
  window.openThread = async function (messageId) {
    // Find the root message of the thread
    let rootMessageId = messageId;
    let currentMsg = messagesCache.get(messageId);

    if (!currentMsg) {
      console.error('Message not found in cache:', messageId);
      return;
    }

    // Traverse up to find the root (a message without replyTo)
    let visitedIds = new Set([messageId]); // Prevent infinite loops
    while (currentMsg && currentMsg.replyTo && currentMsg.replyTo.messageId) {
      const parentId = currentMsg.replyTo.messageId;

      // Check for circular reference
      if (visitedIds.has(parentId)) {
        console.warn('Circular reference detected in thread');
        break;
      }
      visitedIds.add(parentId);

      rootMessageId = parentId;
      const parentMsg = messagesCache.get(parentId);

      // If parent not in cache, stop here and use current rootMessageId
      if (!parentMsg) {
        console.warn('Parent message not in cache:', parentId, '- using current as root');
        break;
      }

      currentMsg = parentMsg;
    }

    currentThreadId = rootMessageId;
    threadPanel.classList.add('visible');
    chatlog.classList.add('thread-open');

    // Load and display root message
    const rootMessage = messagesCache.get(rootMessageId);
    if (rootMessage) {
      threadOriginalMessage.innerHTML = '';
      const msgElement = createMessageElement(rootMessage, false, true);
      threadOriginalMessage.appendChild(msgElement);
    } else {
      threadOriginalMessage.innerHTML = '<p style="color:#999;padding:16px;">Original message not available</p>';
    }

    // Load thread replies
    await loadThreadReplies(rootMessageId);

    // Focus thread input
    threadInput.focus();
  };

  window.closeThread = function () {
    currentThreadId = null;
    threadPanel.classList.remove('visible');
    chatlog.classList.remove('thread-open');
    threadInput.value = '';
  };

  // Reply indicator functions
  function setReplyTo(messageId, username, preview, rootMessageId) {
    currentReplyTo = { messageId, username, preview, rootMessageId };
    const indicator = document.getElementById('reply-indicator');
    const text = indicator.querySelector('.reply-indicator-text');
    text.innerHTML = `Replying to <strong>${username}</strong>: ${preview}`;
    indicator.style.display = 'flex';
    document.getElementById('chat-input').focus();
  }

  function clearReplyTo() {
    currentReplyTo = null;
    document.getElementById('reply-indicator').style.display = 'none';
  }

  // Recursively collect all replies in a thread (depth-first traversal)
  function collectAllThreadReplies(rootMessageId) {
    const allReplies = [];
    const visited = new Set();
    
    function collectReplies(messageId) {
      if (visited.has(messageId)) return;
      visited.add(messageId);
      
      // Get direct replies from threadsCache
      const directReplies = threadsCache.get(messageId) || [];
      
      for (const reply of directReplies) {
        allReplies.push(reply);
        // Recursively collect replies to this reply
        collectReplies(reply.messageId);
      }
    }
    
    collectReplies(rootMessageId);
    return allReplies;
  }

  // Count total replies for a message (including nested)
  function countTotalReplies(messageId) {
    const visited = new Set();
    
    function countReplies(msgId) {
      if (visited.has(msgId)) return 0;
      visited.add(msgId);
      
      let count = 0;
      // Count direct replies
      for (const [cachedMsgId, cachedMsg] of messagesCache.entries()) {
        if (cachedMsg.replyTo && cachedMsg.replyTo.messageId === msgId) {
          count++;
          // Recursively count replies to this reply
          count += countReplies(cachedMsgId);
        }
      }
      return count;
    }
    
    return countReplies(messageId);
  }

  async function loadThreadReplies(messageId) {
    try {
      // Load all thread replies from server in one request
      // Server should return all nested replies in a flat array
      const response = await fetch(`${api.baseUrl}/room/${roomname}/thread/${messageId}?nested=true`);
      if (!response.ok) throw new Error('Failed to load thread');

      const data = await response.json();
      const allReplies = data.replies || [];

      // Cache all replies in messagesCache and organize by parent
      const replyMap = new Map();
      allReplies.forEach(reply => {
        // Cache the message
        messagesCache.set(reply.messageId, reply);
        
        // Organize by parent messageId for threadsCache
        const parentId = reply.replyTo?.messageId;
        if (parentId) {
          if (!replyMap.has(parentId)) {
            replyMap.set(parentId, []);
          }
          replyMap.get(parentId).push(reply);
        }
      });

      // Update threadsCache with organized replies
      replyMap.forEach((replies, parentId) => {
        threadsCache.set(parentId, replies);
      });

      // Update root message with total reply count
      const rootMessage = messagesCache.get(messageId);
      if (rootMessage) {
        rootMessage.threadInfo = {
          replyCount: allReplies.length,
          lastReplyTime: allReplies.length > 0 ? Math.max(...allReplies.map(r => r.timestamp)) : null
        };

        // Re-render the root message with updated count
        threadOriginalMessage.innerHTML = '';
        const msgElement = createMessageElement(rootMessage, false, true);
        threadOriginalMessage.appendChild(msgElement);
      }

      // Render all replies (sorted by timestamp)
      threadReplies.innerHTML = '';
      allReplies.sort((a, b) => a.timestamp - b.timestamp);
      allReplies.forEach(reply => {
        const replyElement = createMessageElement(reply, true);
        threadReplies.appendChild(replyElement);
      });

      // Scroll to bottom
      threadReplies.scrollTop = threadReplies.scrollHeight;
    } catch (err) {
      console.error('Failed to load thread replies:', err);
      threadReplies.innerHTML = '<p style="color:#999;padding:16px;text-align:center;">Failed to load replies</p>';
    }
  }

  function createMessageElement(data, isInThread = false, isThreadOriginal = false) {
    const wrapper = document.createElement('div');
    wrapper.className = 'message-wrapper';
    wrapper.setAttribute('data-message-id', data.messageId);

    const p = document.createElement('p');
    p.style.margin = '0';

    const chatMessage = document.createElement('chat-message');
    chatMessage.setAttribute('username', data.name);
    chatMessage.setAttribute('message', data.message);
    chatMessage.setAttribute('timestamp', String(data.timestamp));
    chatMessage.setAttribute('message-id', data.messageId);
    chatMessage.setAttribute('is-in-thread', isInThread ? 'true' : 'false');

    if (data.replyTo) {
      chatMessage.setAttribute('reply-to', JSON.stringify(data.replyTo));
    }

    if (data.threadInfo && data.threadInfo.replyCount > 0) {
      chatMessage.setAttribute('thread-count', String(data.threadInfo.replyCount));
    }

    p.appendChild(chatMessage);
    wrapper.appendChild(p);

    // Add message actions
    const actions = document.createElement('div');
    actions.className = 'message-actions';

    if (isInThread || isThreadOriginal) {
      // In thread panel - show Locate button
      const locateBtn = document.createElement('button');
      locateBtn.className = 'message-action-btn';
      locateBtn.innerHTML = '📍 Locate';
      locateBtn.title = 'Locate in main chat';
      locateBtn.onclick = (e) => {
        e.stopPropagation();
        locateMessageInMainChat(data.messageId);
      };
      actions.appendChild(locateBtn);
    } else {
      // In main chat - show Reply button
      const replyBtn = document.createElement('button');
      replyBtn.className = 'message-action-btn';
      replyBtn.innerHTML = '💬 Reply';
      replyBtn.onclick = (e) => {
        e.stopPropagation();
        // Set reply target instead of opening thread
        const preview = data.message.substring(0, 50);
        setReplyTo(data.messageId, data.name, preview, data.messageId);
      };
      actions.appendChild(replyBtn);
    }

    wrapper.appendChild(actions);

    return wrapper;
  }

  // Locate and highlight a message in the main chat area
  function locateMessageInMainChat(messageId) {
    // Find the message in main chat
    const mainChatMsg = chatlog.querySelector(`[data-message-id="${messageId}"]`);
    
    if (mainChatMsg) {
      // Scroll to the message
      mainChatMsg.scrollIntoView({ behavior: 'smooth', block: 'center' });
      
      // Highlight the message
      mainChatMsg.style.background = '#fff3cd';
      mainChatMsg.style.transition = 'background 0.3s ease';
      
      // Remove highlight after 2 seconds
      setTimeout(() => {
        mainChatMsg.style.background = '';
      }, 2000);
    } else {
      // Message not found in current view (might be filtered or not loaded)
      addSystemMessage('* Message not found in current chat view');
    }
  }

  // Hashtag functionality
  window.filterByHashtag = function (tag) {
    currentHashtagFilter = tag;
    activeHashtagSpan.textContent = '#' + tag;
    hashtagFilterBanner.classList.add('visible');

    // Update URL with hashtag filter
    const url = new URL(window.location);
    url.searchParams.set('tag', tag);
    window.history.pushState({}, '', url);

    // Update active state in hashtag list
    document.querySelectorAll('.hashtag-item').forEach(item => {
      if (item.dataset.tag === tag) {
        item.classList.add('active');
      } else {
        item.classList.remove('active');
      }
    });

    // Filter messages in chatlog
    const elements = chatlog.querySelectorAll('p');
    elements.forEach(elem => {
      const chatMessage = elem.querySelector('chat-message');
      const systemMessage = elem.querySelector('system-message');

      // Always show system messages
      if (systemMessage) {
        elem.style.display = 'none';
      } else if (chatMessage) {
        const text = chatMessage.getAttribute('message') || '';
        const hasTag = text.toLowerCase().includes('#' + tag.toLowerCase());
        elem.style.display = hasTag ? 'block' : 'none';
      }
    });

    // Scroll to bottom
    chatlog.scrollBy(0, 1e8);
  };

  window.clearHashtagFilter = function () {
    currentHashtagFilter = null;
    hashtagFilterBanner.classList.remove('visible');

    // Remove tag from URL
    const url = new URL(window.location);
    url.searchParams.delete('tag');
    window.history.pushState({}, '', url);

    // Clear active state
    document.querySelectorAll('.hashtag-item').forEach(item => {
      item.classList.remove('active');
    });

    // Show all messages
    const messages = chatlog.querySelectorAll('p');
    messages.forEach(msg => {
      msg.style.display = 'block';
    });

    // Scroll to bottom
    chatlog.scrollBy(0, 1e8);
  };

  async function loadHashtags() {
    try {
      const data = await api.getHashtags(roomname);
      allHashtags = data.hashtags || [];
      renderHashtagList();
    } catch (err) {
      console.error('Failed to load hashtags:', err);
    }
  }

  function renderHashtagList() {
    if (!hashtagList) return;

    hashtagList.innerHTML = '';

    if (allHashtags.length === 0) {
      hashtagList.innerHTML = '<div style="color:#999;font-size:0.85em;padding:8px;">No hashtags yet.<br>Use #tag in messages!</div>';
      return;
    }

    allHashtags.forEach(item => {
      const div = document.createElement('div');
      div.className = 'hashtag-item';
      div.dataset.tag = item.tag;
      if (currentHashtagFilter === item.tag) {
        div.classList.add('active');
      }

      const nameSpan = document.createElement('span');
      nameSpan.className = 'hashtag-name';
      nameSpan.textContent = '#' + item.tag;
      div.appendChild(nameSpan);

      const countSpan = document.createElement('span');
      countSpan.className = 'hashtag-count';
      countSpan.textContent = item.count || 0;
      div.appendChild(countSpan);

      div.onclick = () => {
        window.filterByHashtag(item.tag);
      };

      hashtagList.appendChild(div);
    });
  }

  function updateHashtagsOnNewMessage(message) {
    // Extract hashtags from message
    const hashtagRegex = /#([a-zA-Z0-9_\u4e00-\u9fa5]{2,32})/g;
    const matches = [...message.matchAll(hashtagRegex)];

    if (matches.length > 0) {
      // Reload hashtags after a short delay to get updated counts
      setTimeout(() => loadHashtags(), 500);
    }
  }

  // Room history management
  function getRoomHistory() {
    const history = localStorage.getItem('chatRoomHistory');
    return history ? JSON.parse(history) : [];
  }

  function addToRoomHistory(roomName) {
    let history = getRoomHistory();

    // Remove if already exists (to move to front)
    history = history.filter(item => item.name !== roomName);

    // Add to front
    history.unshift({
      name: roomName,
      timestamp: Date.now()
    });

    // Keep only last 10 rooms
    history = history.slice(0, 10);

    localStorage.setItem('chatRoomHistory', JSON.stringify(history));
  }

  function removeFromRoomHistory(roomName) {
    let history = getRoomHistory();
    history = history.filter(item => item.name !== roomName);
    localStorage.setItem('chatRoomHistory', JSON.stringify(history));
  }

  function displayRoomHistory() {
    const historyList = document.querySelector("#room-history-list");
    const history = getRoomHistory();

    if (history.length === 0) {
      document.querySelector("#room-history").style.display = 'none';
      return;
    }

    document.querySelector("#room-history").style.display = 'block';
    historyList.innerHTML = '';

    history.forEach(item => {
      const div = document.createElement("div");
      div.className = "room-history-item";

      const nameSpan = document.createElement("span");
      nameSpan.className = "room-name";
      nameSpan.innerText = item.name.length === 64 ? 'Private Room' : '#' + item.name;
      nameSpan.title = 'Click to enter ' + item.name;
      div.appendChild(nameSpan);

      const removeBtn = document.createElement("button");
      removeBtn.className = "remove-btn";
      removeBtn.innerText = "×";
      removeBtn.title = "Remove from history";
      removeBtn.onclick = (e) => {
        e.stopPropagation();
        removeFromRoomHistory(item.name);
        displayRoomHistory();
      };
      div.appendChild(removeBtn);

      div.onclick = () => {
        roomname = item.name;
        startChat();
      };

      historyList.appendChild(div);
    });
  }

  function startNameChooser() {
    // Bind event listeners first
    nameForm.addEventListener("submit", event => {
      event.preventDefault();
      username = nameInput.value.trim();
      if (username.length > 0) {
        // Save username to localStorage
        localStorage.setItem('chatUsername', username);
        startRoomChooser();
      }
    });

    nameInput.addEventListener("input", event => {
      if (event.currentTarget.value.length > 32) {
        event.currentTarget.value = event.currentTarget.value.slice(0, 32);
      }
    });

    // Check if username is saved in localStorage
    const savedUsername = localStorage.getItem('chatUsername');
    if (savedUsername) {
      // Pre-fill the username
      nameInput.value = savedUsername;

      // Only auto-submit if we have a room hash in URL
      if (document.location.hash.length > 1) {
        setTimeout(() => {
          nameForm.dispatchEvent(new Event('submit'));
        }, 0);
        return;
      }
    }

    nameInput.focus();
  }

  function startRoomChooser() {
    nameForm.remove();

    if (document.location.hash.length > 1) {
      roomname = document.location.hash.slice(1);
      startChat();
      return;
    }

    // Display room history
    displayRoomHistory();

    roomForm.addEventListener("submit", event => {
      event.preventDefault();
      roomname = roomNameInput.value;
      if (roomname.length > 0) {
        startChat();
      }
    });

    roomNameInput.addEventListener("input", event => {
      if (event.currentTarget.value.length > 32) {
        event.currentTarget.value = event.currentTarget.value.slice(0, 32);
      }
    });

    goPublicButton.addEventListener("click", event => {
      roomname = roomNameInput.value;
      if (roomname.length > 0) {
        startChat();
      }
    });

    goPrivateButton.addEventListener("click", async event => {
      roomNameInput.disabled = true;
      goPublicButton.disabled = true;
      event.currentTarget.disabled = true;

      try {
        roomname = await api.createPrivateRoom();
        startChat();
      } catch (err) {
        alert("something went wrong");
        document.location.reload();
      }
    });

    roomNameInput.focus();
  }

  // Room info state variables (declared at module level for WebSocket access)
  let urlRoomHash = ""; // Store the room hash from URL
  let roomInfoNameDisplay = document.querySelector("#room-name-display");
  let roomInfoNameInput = document.querySelector("#room-name-input");
  let roomInfoNoteTextarea = document.querySelector("#room-note");
  let roomInfoDescriptionLabel = document.querySelector("#room-description-label");

  let documentTitlePrefix = "";
  const { state: roomInfo, subscribe: subscribeRoomInfo } = createReactiveState({
    name: "",
    description: "",
    isLocalUpdate: false
  });

  function startChat() {
    roomForm.remove();

    // Normalize the room name a bit.
    roomname = roomname.replace(/[^a-zA-Z0-9_-]/g, "").replace(/_/g, "-").toLowerCase();

    if (roomname.length > 32 && !roomname.match(/^[0-9a-f]{64}$/)) {
      addSystemMessage("ERROR: Invalid room name.");
      return;
    }

    document.location.hash = "#" + roomname;

    // Save to room history
    addToRoomHistory(roomname);

    // Initialize reactive room info state
    const initialRoomName = roomname.length === 64 ? "Private Room" : "#" + roomname;
    urlRoomHash = roomname.length === 64 ? "" : "#" + roomname;
    roomInfo.name = initialRoomName;

    // Set up reactive listener for document title updates
    subscribeRoomInfo((property, newValue, oldValue) => {
      if (property === 'name') {
        roomInfoNameDisplay.textContent = newValue;

        // Update document title
        let title = newValue;
        if (newValue && newValue !== roomname && urlRoomHash) {
          title = newValue + " " + urlRoomHash;
        }
        documentTitlePrefix = title;
        document.title = documentTitlePrefix + " - Workers Chat";
      } else if (property === 'description') {
        roomInfoNoteTextarea.value = newValue;

        // Show or hide textarea based on content
        if (newValue.trim()) {
          roomInfoNoteTextarea.classList.add("visible");
        } else {
          roomInfoNoteTextarea.classList.remove("visible");
        }
      }
    });

    // Set initial display
    roomInfoNameDisplay.textContent = roomInfo.name;
    documentTitlePrefix = roomInfo.name;
    document.title = documentTitlePrefix + " - Workers Chat";

    // Load room info from server
    async function loadRoomInfo() {
      try {
        const data = await api.getRoomInfo(roomname);
        if (data.name) {
          roomInfo.name = data.name;
        }
        if (data.note) {
          roomInfo.description = data.note;
        }
      } catch (err) {
        console.error('Failed to load room info:', err);
      }
    }

    // Save room info to server
    async function saveRoomInfo() {
      try {
        await api.updateRoomInfo(roomname, {
          name: roomInfo.name,
          note: roomInfo.description
        });
      } catch (err) {
        console.error('Failed to save room info:', err);
      }
    }

    // Load room info on start
    loadRoomInfo();

    // Room name editing
    roomInfoNameDisplay.addEventListener("click", (event) => {
      event.stopPropagation();
      roomInfoNameDisplay.style.display = "none";
      roomInfoNameInput.style.display = "block";
      roomInfoNameInput.value = roomInfo.name;
      roomInfoNameInput.focus();
      roomInfoNameInput.select();
    });

    roomInfoNameInput.addEventListener("blur", () => {
      const newName = roomInfoNameInput.value.trim();
      if (newName && newName !== roomInfo.name) {
        roomInfo.isLocalUpdate = true;
        roomInfo.name = newName;
        saveRoomInfo();
        // Reset flag after a short delay
        setTimeout(() => { roomInfo.isLocalUpdate = false; }, 500);
      }
      roomInfoNameInput.style.display = "none";
      roomInfoNameDisplay.style.display = "block";
    });

    roomInfoNameInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        roomInfoNameInput.blur();
      } else if (event.key === "Escape") {
        roomInfoNameInput.value = roomInfo.name;
        roomInfoNameInput.blur();
      }
    });

    roomInfoNameInput.addEventListener("click", (event) => {
      event.stopPropagation();
    });

    // Room description editing
    roomInfoDescriptionLabel.addEventListener("click", (event) => {
      event.stopPropagation();
      roomInfoNoteTextarea.classList.add("visible");
      roomInfoNoteTextarea.focus();
    });

    // Save room note on change (debounced)
    let saveNoteTimeout;
    roomInfoNoteTextarea.addEventListener("input", () => {
      clearTimeout(saveNoteTimeout);
      saveNoteTimeout = setTimeout(() => {
        roomInfo.isLocalUpdate = true;
        roomInfo.description = roomInfoNoteTextarea.value;
        saveRoomInfo();
        // Reset flag after a short delay
        setTimeout(() => { roomInfo.isLocalUpdate = false; }, 500);
      }, 1000);
    });

    roomInfoNoteTextarea.addEventListener("blur", () => {
      // Hide textarea if empty
      if (!roomInfoNoteTextarea.value.trim()) {
        roomInfoNoteTextarea.classList.remove("visible");
      }
    });

    // Prevent the room note textarea from losing focus
    roomInfoNoteTextarea.addEventListener("mousedown", (event) => {
      event.stopPropagation();
    });

    roomInfoNoteTextarea.addEventListener("click", (event) => {
      event.stopPropagation();
    });

    // Auto-resize textarea function
    function autoResizeTextarea() {
      chatInput.style.height = 'auto';
      let newHeight = Math.min(chatInput.scrollHeight, 150);
      chatInput.style.height = newHeight + 'px';

      // Adjust file upload button height to match
      let btn = document.querySelector("#file-upload-btn");
      btn.style.height = newHeight + 'px';

      // Adjust hashtag toggle button position
      let hashtagBtn = document.querySelector("#hashtag-toggle");
      hashtagBtn.style.bottom = newHeight + 'px';

      // Adjust chatlog, right-sidebar, and hashtag panel bottom position
      chatlog.style.bottom = newHeight + 'px';
      let rightSidebar = document.querySelector("#right-sidebar");
      if (rightSidebar) {
        rightSidebar.style.bottom = newHeight + 'px';
      }
      if (hashtagPanel) {
        hashtagPanel.style.bottom = newHeight + 'px';
      }
    }

    chatInput.addEventListener("keydown", event => {
      // Enter to send (without shift), Shift+Enter for new line
      if (event.keyCode == 13 && !event.shiftKey) {
        event.preventDefault();
        chatroom.dispatchEvent(new Event('submit'));
        return;
      }

      if (event.keyCode == 38 && chatInput.value === "") {
        // up arrow (only if input is empty)
        chatlog.scrollBy(0, -50);
      } else if (event.keyCode == 40 && chatInput.value === "") {
        // down arrow (only if input is empty)
        chatlog.scrollBy(0, 50);
      } else if (event.keyCode == 33) {
        // page up
        chatlog.scrollBy(0, -chatlog.clientHeight + 50);
      } else if (event.keyCode == 34) {
        // page down
        chatlog.scrollBy(0, chatlog.clientHeight - 50);
      }
    });

    chatroom.addEventListener("submit", event => {
      event.preventDefault();

      if (currentWebSocket) {
        let message = chatInput.value.trim();
        if (message.length > 0) {
          const payload = { message: message };

          // If replying to a message, include replyTo information
          if (currentReplyTo) {
            payload.replyTo = {
              messageId: currentReplyTo.messageId,
              username: currentReplyTo.username,
              preview: currentReplyTo.preview
            };
            // Clear reply state after sending
            clearReplyTo();
          }

          currentWebSocket.send(JSON.stringify(payload));
          chatInput.value = "";
          autoResizeTextarea(); // Reset height after sending

          // Scroll to bottom whenever sending a message.
          chatlog.scrollBy(0, 1e8);
          // Set flag to scroll when we receive our own message back
          isAtBottom = true;
        }
      }
    });

    chatInput.addEventListener("input", event => {
      if (event.currentTarget.value.length > 6000) {
        event.currentTarget.value = event.currentTarget.value.slice(0, 6000);
      }
      autoResizeTextarea();
    });

    chatlog.addEventListener("scroll", event => {
      // Allow 1px tolerance for floating point calculation errors
      isAtBottom = chatlog.scrollTop + chatlog.clientHeight >= chatlog.scrollHeight - 1;
    });

    chatInput.focus();
    autoResizeTextarea(); // Initialize textarea size

    document.body.addEventListener("click", event => {
      // If the user clicked somewhere in the window without selecting any text, focus the chat
      // input. But don't steal focus from textareas or input fields.
      const isTextInput = event.target.tagName === 'TEXTAREA' || event.target.tagName === 'INPUT';
      if (window.getSelection().toString() == "" && !isTextInput) {
        chatInput.focus();
      }
    });

    // Hashtag panel toggle
    hashtagToggle.addEventListener("click", event => {
      event.stopPropagation();
      hashtagPanel.classList.toggle('visible');
      if (hashtagPanel.classList.contains('visible')) {
        loadHashtags();
      }
    });

    // Thread panel close
    threadClose.addEventListener("click", event => {
      event.stopPropagation();
      window.closeThread();
    });

    // Reply indicator close button
    replyIndicatorClose.addEventListener("click", () => {
      clearReplyTo();
    });

    // Thread input - send reply
    threadInput.addEventListener("keydown", event => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        sendThreadReply();
      }
    });

    async function sendThreadReply() {
      const message = threadInput.value.trim();
      if (!message || !currentThreadId || !currentWebSocket) return;

      const originalMessage = messagesCache.get(currentThreadId);
      if (!originalMessage) return;

      // Send reply with replyTo information
      currentWebSocket.send(JSON.stringify({
        message: message,
        replyTo: {
          messageId: currentThreadId,
          username: originalMessage.name,
          preview: originalMessage.message.substring(0, 100)
        }
      }));

      threadInput.value = '';
    }

    // Upload file function
    async function uploadFile(file, fileName = null) {
      try {
        // Create form data
        const formData = new FormData();
        formData.append("file", file, fileName || file.name);

        // Upload file
        const result = await api.uploadFile(roomname, formData);

        // Send file message through WebSocket
        if (currentWebSocket) {
          const fileMessage = `FILE:${result.fileUrl}|${result.fileName}|${result.fileType}`;
          currentWebSocket.send(JSON.stringify({ message: fileMessage }));
        }

        return true;
      } catch (err) {
        addSystemMessage("* Upload failed: " + err.message);
        return false;
      }
    }

    // File upload button click handler
    fileUploadBtn.addEventListener("click", event => {
      fileInput.click();
    });

    // File input change handler
    fileInput.addEventListener("change", async event => {
      const file = event.target.files[0];
      if (!file) return;

      // Show uploading message
      addSystemMessage("* Uploading file...");

      const success = await uploadFile(file);
      if (success) {
        // Clear the file input
        fileInput.value = "";
      }
    });

    // Handle paste events for files and text
    chatInput.addEventListener("paste", async event => {
      const items = event.clipboardData?.items;
      if (!items) return;

      // Check for any file (images, documents, etc.)
      for (let item of items) {
        // Skip plain text items (let them paste normally)
        if (item.kind === "file") {
          event.preventDefault();

          const file = item.getAsFile();
          if (!file) continue;

          // Determine file type for display
          const fileType = item.type.startsWith("image/") ? "image" : "file";

          // Show uploading message
          addSystemMessage(`* Uploading pasted ${fileType}...`);

          // Use file name if available, otherwise generate one with timestamp
          let fileName = file.name;
          if (!fileName || fileName === 'image.png' || fileName === 'blob') {
            // Generate filename with timestamp for unnamed files
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const extension = file.type.split('/')[1] || 'bin';
            fileName = `pasted-${timestamp}.${extension}`;
          }

          await uploadFile(file, fileName);

          return; // Stop after processing the first file
        }
      }

      // If no file was found, allow default text paste behavior
    });

    // Detect mobile keyboard appearing and disappearing, and adjust the scroll as appropriate.
    if ('visualViewport' in window) {
      window.visualViewport.addEventListener('resize', function (event) {
        if (isAtBottom) {
          chatlog.scrollBy(0, 1e8);
        }
      });
    }

    join();
  }

  let lastSeenTimestamp = 0;
  let wroteWelcomeMessages = false;
  let isReconnecting = false; // Track if this is a reconnection

  function join() {
    let ws = new WebSocket(api.getWebSocketUrl(roomname));
    let rejoined = false;
    let startTime = Date.now();

    let rejoin = async () => {
      if (!rejoined) {
        rejoined = true;
        currentWebSocket = null;
        isReconnecting = true; // Mark as reconnecting

        // Clear the roster.
        while (roster.firstChild) {
          roster.removeChild(roster.firstChild);
        }

        // Don't try to reconnect too rapidly.
        let timeSinceLastJoin = Date.now() - startTime;
        if (timeSinceLastJoin < 3000) {
          // Less than 3 seconds elapsed since last join. Pause a bit.
          await new Promise(resolve => setTimeout(resolve, 3000 - timeSinceLastJoin));
        }

        // OK, reconnect now!
        join();
      }
    }

    ws.addEventListener("open", event => {
      currentWebSocket = ws;

      // Send user info message.
      ws.send(JSON.stringify({ name: username }));
    });

    ws.addEventListener("message", event => {
      let data = JSON.parse(event.data);

      if (data.error) {
        addSystemMessage("* Error: " + data.error);
      } else if (data.threadUpdate) {
        // Thread info has been updated
        const msgElement = document.querySelector(`[data-message-id="${data.threadUpdate.messageId}"]`);
        if (msgElement) {
          const chatMessage = msgElement.querySelector('chat-message');
          if (chatMessage && data.threadUpdate.threadInfo) {
            chatMessage.setAttribute('thread-count', String(data.threadUpdate.threadInfo.replyCount));
            chatMessage.render();  // Re-render to show updated thread count
          }
        }

        // Update cache
        const cachedMsg = messagesCache.get(data.threadUpdate.messageId);
        if (cachedMsg) {
          cachedMsg.threadInfo = data.threadUpdate.threadInfo;
        }

        // If this is the current open thread, update the top message display
        if (currentThreadId === data.threadUpdate.messageId) {
          const rootMessage = messagesCache.get(currentThreadId);
          if (rootMessage) {
            threadOriginalMessage.innerHTML = '';
            const msgElement = createMessageElement(rootMessage, false, true);
            threadOriginalMessage.appendChild(msgElement);
          }
        }
      } else if (data.roomInfoUpdate) {
        // Room info has been updated, refresh the display
        // Skip if this is our own update to avoid flickering
        if (!roomInfo.isLocalUpdate) {
          const info = data.roomInfoUpdate;
          let updated = false;

          if (info.name !== undefined && info.name !== roomInfo.name) {
            roomInfo.name = info.name;
            updated = true;
          }

          if (info.note !== undefined && info.note !== roomInfo.description) {
            roomInfo.description = info.note;
            updated = true;
          }

          // Show a notification that room info was updated
          if (updated) {
            addSystemMessage("* Room info has been updated");
          }
        }
      } else if (data.joined) {
        let userItem = document.createElement("div");
        userItem.className = "user-item";

        let userName = document.createElement("span");
        userName.innerText = data.joined + (data.joined === username ? " (me)" : "");
        userItem.appendChild(userName);

        // Add logout button only for current user
        if (data.joined === username) {
          let logoutBtn = document.createElement("button");
          logoutBtn.className = "logout-btn";
          logoutBtn.innerText = "×";
          logoutBtn.title = "Logout and change username";
          logoutBtn.onclick = (e) => {
            e.stopPropagation();
            // Clear saved username
            localStorage.removeItem('chatUsername');
            // Close WebSocket
            if (currentWebSocket) {
              currentWebSocket.close();
            }
            // Reload page without hash to start fresh
            window.location.href = window.location.href.split('#')[0];
          };
          userItem.appendChild(logoutBtn);
        }

        roster.appendChild(userItem);
      } else if (data.quit) {
        for (let child of roster.childNodes) {
          const userName = child.querySelector ? child.querySelector("span")?.innerText : child.innerText;
          if (userName == data.quit || userName == data.quit + " (me)") {
            roster.removeChild(child);
            break;
          }
        }
      } else if (data.ready) {
        // All pre-join messages have been delivered.
        if (!wroteWelcomeMessages) {
          wroteWelcomeMessages = true;
          addSystemMessage(
            "* This is a app built with Cloudflare Workers Durable Objects. The source code " +
            "can be found at: https://github.com/bytemain/workers-chat"
          );
          addSystemMessage(
            "* WARNING: Participants in this chat are random people on the internet. " +
            "Names are not authenticated; anyone can pretend to be anyone.Chat history is saved."
          );
          if (roomname.length == 64) {
            addSystemMessage(
              "* This is a private room. You can invite someone to the room by sending them the URL."
            );
          } else {
            addSystemMessage(
              "* Welcome to " +
              documentTitlePrefix +
              ". Say hi!"
            );
          }

          loadHashtags().then(() => {
            // Check if there's a tag filter in the URL
            const urlParams = new URLSearchParams(window.location.search);
            const tagParam = urlParams.get('tag');
            if (tagParam) {
              // Apply the filter from URL
              window.filterByHashtag(tagParam);
            }
          });
        } else if (isReconnecting) {
          // Show reconnection success message
          addSystemMessage("* Reconnected successfully.");
          isReconnecting = false;
        }
      } else {
        // A regular chat message.
        if (data.timestamp > lastSeenTimestamp) {
          addChatMessage(data.name, data.message, data.timestamp, {
            messageId: data.messageId,
            replyTo: data.replyTo,
            threadInfo: data.threadInfo
          });
          lastSeenTimestamp = data.timestamp;

          // Scroll to bottom if we were at bottom (includes our own messages)
          if (isAtBottom) {
            chatlog.scrollBy(0, 1e8);
          }
        }
      }
    });

    ws.addEventListener("close", event => {
      console.log("WebSocket closed, reconnecting:", event.code, event.reason);
      if (event.code === 1008 || event.code === 1009) {
        // Username invalid or banned - clear saved username
        localStorage.removeItem('chatUsername');
        shouldReconnect = false; // Don't reconnect
      } else {
        addSystemMessage("* Disconnected from server. Reconnecting...");
        rejoin();
      }
    });
    ws.addEventListener("error", event => {
      console.log("WebSocket error, reconnecting:", event);
      addSystemMessage("* Connection error. Reconnecting...");
      rejoin();
    });
  }

  // Global variable for cross-day pagination
  let lastMsgDateStr = null;

  function addSystemMessage(text) {
    let p = document.createElement("p");
    const sysMsg = document.createElement('system-message');
    sysMsg.setAttribute('message', text);
    p.appendChild(sysMsg);
    chatlog.appendChild(p);
    isAtBottom = true;
    chatlog.scrollBy(0, 1e8);
  }

  function addChatMessage(name, text, ts, msgData = {}) {
    // ts: message timestamp (ms)
    let timestamp = ts;
    if (typeof timestamp !== 'number') {
      timestamp = Date.now();
    }

    // Generate or use existing messageId
    const messageId = msgData.messageId || generateLegacyMessageId(timestamp, name);

    // Create complete message data
    const messageData = {
      name: name,
      message: text,
      timestamp: timestamp,
      messageId: messageId,
      replyTo: msgData.replyTo || null,
      threadInfo: msgData.threadInfo || null
    };

    // Cache the message
    messagesCache.set(messageId, messageData);

    const date = new Date(timestamp);
    const dateStr = date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0') + '-' + String(date.getDate()).padStart(2, '0');

    // Insert date divider if day changes
    if (lastMsgDateStr !== dateStr) {
      lastMsgDateStr = dateStr;
      const divider = document.createElement('div');
      divider.className = 'date-divider';
      divider.textContent = dateStr;
      divider.style.textAlign = 'center';
      divider.style.color = '#aaa';
      divider.style.fontSize = '0.9em';
      divider.style.margin = '16px 0 8px 0';
      chatlog.appendChild(divider);
    }

    // Create message element using new function
    const messageElement = createMessageElement(messageData, false);

    // Check if message should be hidden based on current filter
    if (currentHashtagFilter) {
      const hasTag = text.toLowerCase().includes('#' + currentHashtagFilter.toLowerCase());
      if (!hasTag) {
        messageElement.style.display = 'none';
      }
    }

    // Append message to main chat
    chatlog.appendChild(messageElement);

    // If this is a reply and the thread is open, also add to thread panel
    if (msgData.replyTo) {
      // Find the root message of this reply
      let rootId = msgData.replyTo.messageId;
      let parentMsg = messagesCache.get(rootId);
      while (parentMsg && parentMsg.replyTo) {
        rootId = parentMsg.replyTo.messageId;
        parentMsg = messagesCache.get(rootId);
      }

      // Update root message's reply count
      const rootMessage = messagesCache.get(rootId);
      if (rootMessage) {
        const totalReplies = countTotalReplies(rootId);
        rootMessage.threadInfo = rootMessage.threadInfo || {};
        rootMessage.threadInfo.replyCount = totalReplies;
        rootMessage.threadInfo.lastReplyTime = timestamp;

        // Update the message in main chat list
        const mainChatMsg = document.querySelector(`[data-message-id="${rootId}"]`);
        if (mainChatMsg) {
          const chatMessage = mainChatMsg.querySelector('chat-message');
          if (chatMessage) {
            chatMessage.setAttribute('thread-count', String(totalReplies));
            chatMessage.render();
          }
        }
      }

      // If this reply belongs to the currently open thread, add it
      if (currentThreadId === rootId) {
        const threadReplyElement = createMessageElement(messageData, true);
        threadReplies.appendChild(threadReplyElement);
        threadReplies.scrollTop = threadReplies.scrollHeight;

        // Update thread count on the top message in thread panel
        if (rootMessage) {
          threadOriginalMessage.innerHTML = '';
          const msgElement = createMessageElement(rootMessage, false, true);
          threadOriginalMessage.appendChild(msgElement);
        }
      }
    }

    if (isAtBottom) {
      chatlog.scrollBy(0, 1e8);
    }

    // Update hashtags if message contains any
    updateHashtagsOnNewMessage(text);
  }

  // Listen for hash changes to switch rooms
  window.addEventListener('hashchange', () => {
    const newRoomName = document.location.hash.slice(1);
    // Only reload if we're in a different room (not initial room setup)
    if (roomname && newRoomName !== roomname) {
      window.location.reload();
    }
  });

  startNameChooser();
</script>

</html>