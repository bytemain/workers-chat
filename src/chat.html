<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!--===================================================================================-->
  <style type="text/css">
    * {
      box-sizing: border-box;
    }

    body {
      font-family: Arial, Helvetica, sans-serif;
    }

    #chatlog {
      position: fixed;
      top: 0;
      bottom: 32px;
      left: 0;
      right: 200px;
      overflow-y: auto;
      padding: 8px;
      overflow-wrap: break-word;
      transition: bottom 0.1s ease;
    }

    #chatlog span.username {
      font-weight: bold;
    }

    #spacer {
      height: calc(100vh - 32px - 5em);
    }

    #room-info {
      position: fixed;
      right: 0;
      top: 0;
      width: 200px;
      border-left: 1px solid #ddd;
      border-bottom: 1px solid #ddd;
      background: #fafafa;
      padding: 8px;
      font-size: 0.9em;
    }

    #room-info h3 {
      margin: 0 0 8px 0;
      font-size: 1em;
      color: #333;
    }

    #room-name-display {
      font-weight: bold;
      color: #1da1f2;
      margin-bottom: 8px;
      word-break: break-all;
    }

    #room-note {
      width: 100%;
      min-height: 60px;
      padding: 6px;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-family: Arial, sans-serif;
      font-size: 0.9em;
      resize: vertical;
      background: white;
    }

    #room-note:focus {
      outline: none;
      border-color: #1da1f2;
    }

    #room-info {
      position: fixed;
      right: 0;
      top: 0;
      width: 200px;
      border-left: 1px solid #ddd;
      border-bottom: 1px solid #ddd;
      background: #fafafa;
      padding: 8px;
      font-size: 0.9em;
    }

    #room-info h3 {
      margin: 0 0 8px 0;
      font-size: 1em;
      color: #333;
    }

    #room-name-display {
      font-weight: bold;
      color: #1da1f2;
      margin-bottom: 8px;
      word-break: break-all;
    }

    #room-note {
      width: 100%;
      min-height: 60px;
      padding: 6px;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-family: Arial, sans-serif;
      font-size: 0.9em;
      resize: vertical;
      background: white;
    }

    #room-note:focus {
      outline: none;
      border-color: #1da1f2;
    }

    #roster {
      font-weight: bold;
      padding: 8px;
    }

    #roster h3 {
      margin: 0 0 8px 0;
      font-size: 1em;
      color: #333;
    }

    #roster .user-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    #roster .logout-btn {
      background: transparent;
      color: #999;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 1px 6px;
      cursor: pointer;
      font-size: 11px;
      margin-left: 8px;
    }

    #roster .logout-btn:hover {
      background: #f5f5f5;
      color: #666;
      border-color: #ccc;
    }

    p {
      margin-top: 0;
      margin-bottom: 8px;
    }

    p:last-of-type {
      margin: 0;
    }

    #roster {
      position: fixed;
      right: 0;
      top: 160px;
      bottom: 32px;
      width: 200px;
      border-left: 1px solid #ddd;
      transition: bottom 0.1s ease;
      overflow-y: auto;
      background: white;
    }

    ::-webkit-scrollbar {
      display: none;
    }

    @media(max-width:600px) {
      #room-info {
        display: none;
      }

      #roster {
        display: none;
      }

      #chatlog {
        right: 0;
      }
    }

    #chat-input {
      position: fixed;
      width: calc(100% - 40px);
      min-height: 32px;
      max-height: 150px;
      bottom: 0;
      left: 0;
      border: none;
      border-top: none;
      padding-left: 32px;
      padding-top: 8px;
      padding-bottom: 8px;
      padding-right: 8px;
      outline: none;
      resize: none;
      overflow-y: auto;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 16px;
      line-height: 1.2;
    }

    #file-upload-btn {
      position: fixed;
      width: 40px;
      min-height: 32px;
      bottom: 0;
      right: 0;
      border: none;
      background: #f0f0f0;
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #file-upload-btn:hover {
      background: #e0e0e0;
    }

    #file-input {
      display: none;
    }

    #chatroom::before {
      z-index: 1;
      display: block;
      content: ">";
      position: fixed;
      bottom: 0;
      left: 0;
      width: 32px;
      height: 32px;
      line-height: 32px;
      text-align: center;
      font-weight: bold;
      color: #888;
      -webkit-text-stroke-width: 2px;
    }

    #name-form {
      position: fixed;
      z-index: 3;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: white;
    }

    #name-input {
      position: fixed;
      font-size: 200%;
      top: calc(50% - 1em);
      left: calc(50% - 8em);
      width: 16em;
      height: 2em;
      margin: 0;
      text-align: center;
      border: 1px solid #bbb;
    }

    #name-form p {
      position: fixed;
      top: calc(50% + 3em);
      width: 100%;
      text-align: center;
    }

    #room-form {
      position: fixed;
      z-index: 2;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: white;
      font-size: 200%;
      margin-top: calc(50vh - 3em);
      text-align: center;
    }

    #room-name {
      font-size: inherit;
      border: 1px solid #bbb;
      height: 2em;
      width: 16em;
      padding-left: 1em;
    }

    #room-form button {
      font-size: inherit;
      border: 1px solid #bbb;
      background-color: #eee;
      height: 2em;
    }

    @media(max-width:660px) {

      #name-input,
      #room-form {
        font-size: 150%;
      }

      #name-form p {
        font-size: 75%;
      }
    }

    @media(max-width:500px) {

      #name-input,
      #room-form {
        font-size: 100%;
      }

      #name-form p {
        font-size: 50%;
      }
    }

    #go-public {
      width: 4em;
    }

    #go-private {
      width: 20em;
    }

    #room-history {
      margin-top: 2em;
      font-size: 0.6em;
    }

    #room-history h3 {
      margin: 0 0 0.5em 0;
      color: #666;
    }

    #room-history-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5em;
      justify-content: center;
      max-width: 600px;
      margin: 0 auto;
    }

    .room-history-item {
      background: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 0.5em 1em;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5em;
    }

    .room-history-item:hover {
      background: #e0e0e0;
      border-color: #ccc;
    }

    .room-history-item .room-name {
      font-weight: bold;
    }

    .room-history-item .remove-btn {
      background: transparent;
      border: none;
      color: #999;
      cursor: pointer;
      font-size: 1.2em;
      padding: 0 0.2em;
      line-height: 1;
    }

    .room-history-item .remove-btn:hover {
      color: #f00;
    }

    /* Hashtag styles */
    a.hashtag {
      color: #1da1f2;
      font-weight: 500;
      text-decoration: none;
      cursor: pointer;
      padding: 0 2px;
      border-radius: 2px;
      transition: background-color 0.2s;
    }

    a.hashtag:hover {
      background-color: #e8f5fd;
      text-decoration: underline;
    }

    #hashtag-panel {
      position: fixed;
      right: 0;
      top: 0;
      bottom: 32px;
      width: 200px;
      border-left: 1px solid #ddd;
      background: #fafafa;
      overflow-y: auto;
      padding: 8px;
      font-size: 0.9em;
      transition: bottom 0.1s ease;
      display: none;
      z-index: 100;
    }

    #hashtag-panel.visible {
      display: block;
    }

    #hashtag-panel h3 {
      margin: 0 0 12px 0;
      font-size: 1em;
      color: #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #hashtag-toggle {
      position: fixed;
      right: 0;
      bottom: 32px;
      width: 40px;
      height: 32px;
      background: #f0f0f0;
      border: none;
      border-top: 1px solid #ddd;
      border-left: 1px solid #ddd;
      cursor: pointer;
      font-size: 18px;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #hashtag-toggle:hover {
      background: #e0e0e0;
    }

    #hashtag-toggle.active {
      background: #1da1f2;
      color: white;
    }

    .hashtag-item {
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 6px 8px;
      margin-bottom: 6px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .hashtag-item:hover {
      background: #f0f8ff;
      border-color: #1da1f2;
    }

    .hashtag-item.active {
      background: #e8f5fd;
      border-color: #1da1f2;
      font-weight: bold;
    }

    .hashtag-name {
      color: #1da1f2;
      font-weight: 500;
    }

    .hashtag-count {
      color: #999;
      font-size: 0.85em;
    }

    #hashtag-filter-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 200px;
      background: #fff3cd;
      border-bottom: 1px solid #ffc107;
      padding: 8px 16px;
      display: none;
      align-items: center;
      justify-content: space-between;
      z-index: 5;
    }

    #hashtag-filter-banner.visible {
      display: flex;
    }

    #hashtag-filter-banner+#chatlog {
      top: 41px;
    }

    .filter-clear-btn {
      background: #ffc107;
      color: #333;
      border: none;
      border-radius: 3px;
      padding: 4px 12px;
      cursor: pointer;
      font-size: 0.9em;
    }

    .filter-clear-btn:hover {
      background: #ffb300;
    }

    @media(max-width:600px) {
      #hashtag-panel {
        display: none !important;
      }

      #hashtag-toggle {
        display: none;
      }

      #chatlog {
        right: 0;
      }

      #hashtag-filter-banner {
        right: 0;
      }
    }
  </style>

</head>

<body>
  <form id="name-form" action="/fake-form-action">
    <input id="name-input" placeholder="your name">
    <p>This chat runs entirely on the edge, powered by<br>
      <a href="https://blog.cloudflare.com/introducing-workers-durable-objects" target="_blank">Cloudflare Workers
        Durable Objects</a>
    </p>
  </form>
  <form id="room-form" action="/fake-form-action">
    <p>Enter a public room:</p>
    <input id="room-name" placeholder="room name"><button id="go-public">Go &raquo;</button>
    <p>OR</p>
    <button id="go-private">Create a Private Room &raquo;</button>
    <div id="room-history">
      <h3>Recent Rooms</h3>
      <div id="room-history-list"></div>
    </div>
  </form>
  <div id="hashtag-filter-banner">
    <span>Filtering by: <strong id="active-hashtag"></strong></span>
    <button class="filter-clear-btn" onclick="clearHashtagFilter()">Clear Filter ✕</button>
  </div>
  <div id="hashtag-panel">
    <h3>
      <span>📌 Hashtags</span>
      <button id="hashtag-close" style="background:none;border:none;cursor:pointer;font-size:18px;"
        title="Close">✕</button>
    </h3>
    <div id="hashtag-list"></div>
  </div>
  <form id="chatroom" action="/fake-form-action">
    <div id="chatlog">
      <div id="spacer"></div>
    </div>
    <div id="room-info">
      <h3>🏠 Room Info</h3>
      <div id="room-name-display"></div>
      <textarea id="room-note" placeholder="Add room notes here..."></textarea>
    </div>
    <div id="roster">
      <h3>👥 Online Members</h3>
    </div>
    <textarea id="chat-input" rows="1" placeholder="Type a message..."></textarea>
    <input type="file" id="file-input" accept="image/*,application/pdf,.doc,.docx,.txt">
    <button type="button" id="file-upload-btn" title="Upload file">📎</button>
    <button type="button" id="hashtag-toggle" title="Toggle hashtags">#</button>
  </form>
</body>
<script type="text/javascript">

  // System message custom element
  class SystemMessage extends HTMLElement {
    connectedCallback() {
      this.render();
    }
    render() {
      const message = this.getAttribute('message');
      this.innerHTML = '';
      const sysSpan = document.createElement('span');
      sysSpan.className = 'system-message';
      sysSpan.textContent = message;
      sysSpan.style.color = '#888';
      sysSpan.style.fontStyle = 'italic';
      this.appendChild(sysSpan);
    }
  }
  customElements.define('system-message', SystemMessage);

  // Define custom element for chat messages
  class ChatMessage extends HTMLElement {
    connectedCallback() {
      this.render();
    }

    render() {
      const username = this.getAttribute('username');
      const message = this.getAttribute('message');
      const timestamp = this.getAttribute('timestamp');

      // Clear existing content
      this.innerHTML = '';

      // Add time if present
      if (timestamp) {
        const date = new Date(Number(timestamp));
        const hh = String(date.getHours()).padStart(2, '0');
        const mm = String(date.getMinutes()).padStart(2, '0');
        const ss = String(date.getSeconds()).padStart(2, '0');
        const timeSpan = document.createElement('span');
        timeSpan.className = 'msg-time';
        timeSpan.textContent = `[${hh}:${mm}:${ss}] `;
        timeSpan.style.color = '#888';
        timeSpan.style.fontSize = '0.95em';
        this.appendChild(timeSpan);
      }

      // Add username if present
      if (username) {
        const usernameSpan = document.createElement('span');
        usernameSpan.className = 'username';
        usernameSpan.textContent = username + ': ';
        this.appendChild(usernameSpan);
      }

      // Handle file messages (check inside the element)
      if (message.startsWith("FILE:")) {
        this.renderFileMessage(message);
      } else {
        // Handle regular text messages with link detection
        this.renderTextMessage(message);
      }
    }

    renderFileMessage(message) {
      const parts = message.substring(5).split("|");
      const fileUrl = parts[0];
      const fileName = parts[1] || "file";
      const fileType = parts[2] || "";

      // If it's an image, display it inline
      if (fileType.startsWith("image/")) {
        const img = document.createElement("img");
        img.src = fileUrl;
        img.alt = fileName;
        img.style.maxWidth = "300px";
        img.style.maxHeight = "300px";
        img.style.display = "block";
        img.style.marginTop = "5px";
        img.style.cursor = "pointer";
        img.onclick = () => window.open(fileUrl, "_blank");
        this.appendChild(img);

        const link = document.createElement("a");
        link.href = fileUrl;
        link.target = "_blank";
        link.textContent = fileName;
        link.style.fontSize = "0.9em";
        this.appendChild(document.createElement("br"));
        this.appendChild(link);
      } else {
        // For other files, just show a download link
        const link = document.createElement("a");
        link.href = fileUrl;
        link.download = fileName;
        link.target = "_blank";
        link.textContent = "📎 " + fileName;
        this.appendChild(link);
      }
    }

    renderTextMessage(text) {
      // Combined regex pattern - matches URLs and hashtags
      // URLs: http://, https://, and www. URLs
      // Hashtags: #word (2-32 chars, alphanumeric, underscore, Chinese)
      const combinedRegex = /(https?:\/\/[^\s]+)|(www\.[^\s]+)|(#[a-zA-Z0-9_\u4e00-\u9fa5]{2,32})/g;

      let lastIndex = 0;
      let match;

      // Find all URLs and hashtags in the text
      while ((match = combinedRegex.exec(text)) !== null) {
        // Add text before the match
        if (match.index > lastIndex) {
          const textNode = document.createTextNode(text.substring(lastIndex, match.index));
          this.appendChild(textNode);
        }

        if (match[3]) {
          // It's a hashtag
          const hashtag = match[3];
          const link = document.createElement('a');
          link.className = 'hashtag';
          link.href = '#';
          link.textContent = hashtag;
          link.dataset.tag = hashtag.substring(1); // Remove the # prefix
          link.onclick = (e) => {
            e.preventDefault();
            window.filterByHashtag(link.dataset.tag);
          };
          this.appendChild(link);
        } else {
          // It's a URL
          const link = document.createElement('a');
          let url = match[0];

          // Add https:// if it's a www. link
          if (url.startsWith('www.')) {
            link.href = 'https://' + url;
          } else {
            link.href = url;
          }

          link.target = '_blank';
          link.rel = 'noopener noreferrer';
          link.textContent = url;
          link.style.color = '#0066cc';
          link.style.textDecoration = 'underline';
          this.appendChild(link);
        }

        lastIndex = combinedRegex.lastIndex;
      }

      // Add remaining text after last match (or all text if no matches found)
      if (lastIndex < text.length) {
        const textNode = document.createTextNode(text.substring(lastIndex));
        this.appendChild(textNode);
      }
    }
  }

  // Register the custom element
  customElements.define('chat-message', ChatMessage);

  let currentWebSocket = null;

  let nameForm = document.querySelector("#name-form");
  let nameInput = document.querySelector("#name-input");
  let roomForm = document.querySelector("#room-form");
  let roomNameInput = document.querySelector("#room-name");
  let goPublicButton = document.querySelector("#go-public");
  let goPrivateButton = document.querySelector("#go-private");
  let chatroom = document.querySelector("#chatroom");
  let chatlog = document.querySelector("#chatlog");
  let chatInput = document.querySelector("#chat-input");
  let roster = document.querySelector("#roster");
  let fileInput = document.querySelector("#file-input");
  let fileUploadBtn = document.querySelector("#file-upload-btn");
  let hashtagPanel = document.querySelector("#hashtag-panel");
  let hashtagToggle = document.querySelector("#hashtag-toggle");
  let hashtagList = document.querySelector("#hashtag-list");
  let hashtagFilterBanner = document.querySelector("#hashtag-filter-banner");
  let activeHashtagSpan = document.querySelector("#active-hashtag");

  // Is the chatlog scrolled to the bottom?
  let isAtBottom = true;

  let username;
  let roomname;
  let currentHashtagFilter = null; // Current active hashtag filter
  let allHashtags = []; // Cache of all hashtags

  let hostname = window.location.host;
  if (hostname == "") {
    // Probably testing the HTML locally.
    hostname = "edge-chat-demo.cloudflareworkers.com";
  }

  // Hashtag functionality
  window.filterByHashtag = function (tag) {
    currentHashtagFilter = tag;
    activeHashtagSpan.textContent = '#' + tag;
    hashtagFilterBanner.classList.add('visible');

    // Update URL with hashtag filter
    const url = new URL(window.location);
    url.searchParams.set('tag', tag);
    window.history.pushState({}, '', url);

    // Update active state in hashtag list
    document.querySelectorAll('.hashtag-item').forEach(item => {
      if (item.dataset.tag === tag) {
        item.classList.add('active');
      } else {
        item.classList.remove('active');
      }
    });

    // Filter messages in chatlog
    const elements = chatlog.querySelectorAll('p');
    elements.forEach(elem => {
      const chatMessage = elem.querySelector('chat-message');
      const systemMessage = elem.querySelector('system-message');

      // Always show system messages
      if (systemMessage) {
        elem.style.display = 'none';
      } else if (chatMessage) {
        const text = chatMessage.getAttribute('message') || '';
        const hasTag = text.toLowerCase().includes('#' + tag.toLowerCase());
        elem.style.display = hasTag ? 'block' : 'none';
      }
    });

    // Scroll to bottom
    chatlog.scrollBy(0, 1e8);
  };

  window.clearHashtagFilter = function () {
    currentHashtagFilter = null;
    hashtagFilterBanner.classList.remove('visible');

    // Remove tag from URL
    const url = new URL(window.location);
    url.searchParams.delete('tag');
    window.history.pushState({}, '', url);

    // Clear active state
    document.querySelectorAll('.hashtag-item').forEach(item => {
      item.classList.remove('active');
    });

    // Show all messages
    const messages = chatlog.querySelectorAll('p');
    messages.forEach(msg => {
      msg.style.display = 'block';
    });

    // Scroll to bottom
    chatlog.scrollBy(0, 1e8);
  };

  async function loadHashtags() {
    try {
      const response = await fetch(`https://${hostname}/api/room/${roomname}/hashtags`);
      if (!response.ok) return;

      const data = await response.json();
      allHashtags = data.hashtags || [];
      renderHashtagList();
    } catch (err) {
      console.error('Failed to load hashtags:', err);
    }
  }

  function renderHashtagList() {
    if (!hashtagList) return;

    hashtagList.innerHTML = '';

    if (allHashtags.length === 0) {
      hashtagList.innerHTML = '<div style="color:#999;font-size:0.85em;padding:8px;">No hashtags yet.<br>Use #tag in messages!</div>';
      return;
    }

    allHashtags.forEach(item => {
      const div = document.createElement('div');
      div.className = 'hashtag-item';
      div.dataset.tag = item.tag;
      if (currentHashtagFilter === item.tag) {
        div.classList.add('active');
      }

      const nameSpan = document.createElement('span');
      nameSpan.className = 'hashtag-name';
      nameSpan.textContent = '#' + item.tag;
      div.appendChild(nameSpan);

      const countSpan = document.createElement('span');
      countSpan.className = 'hashtag-count';
      countSpan.textContent = item.count || 0;
      div.appendChild(countSpan);

      div.onclick = () => {
        window.filterByHashtag(item.tag);
      };

      hashtagList.appendChild(div);
    });
  }

  function updateHashtagsOnNewMessage(message) {
    // Extract hashtags from message
    const hashtagRegex = /#([a-zA-Z0-9_\u4e00-\u9fa5]{2,32})/g;
    const matches = [...message.matchAll(hashtagRegex)];

    if (matches.length > 0) {
      // Reload hashtags after a short delay to get updated counts
      setTimeout(() => loadHashtags(), 500);
    }
  }

  // Room history management
  function getRoomHistory() {
    const history = localStorage.getItem('chatRoomHistory');
    return history ? JSON.parse(history) : [];
  }

  function addToRoomHistory(roomName) {
    let history = getRoomHistory();

    // Remove if already exists (to move to front)
    history = history.filter(item => item.name !== roomName);

    // Add to front
    history.unshift({
      name: roomName,
      timestamp: Date.now()
    });

    // Keep only last 10 rooms
    history = history.slice(0, 10);

    localStorage.setItem('chatRoomHistory', JSON.stringify(history));
  }

  function removeFromRoomHistory(roomName) {
    let history = getRoomHistory();
    history = history.filter(item => item.name !== roomName);
    localStorage.setItem('chatRoomHistory', JSON.stringify(history));
  }

  function displayRoomHistory() {
    const historyList = document.querySelector("#room-history-list");
    const history = getRoomHistory();

    if (history.length === 0) {
      document.querySelector("#room-history").style.display = 'none';
      return;
    }

    document.querySelector("#room-history").style.display = 'block';
    historyList.innerHTML = '';

    history.forEach(item => {
      const div = document.createElement("div");
      div.className = "room-history-item";

      const nameSpan = document.createElement("span");
      nameSpan.className = "room-name";
      nameSpan.innerText = item.name.length === 64 ? 'Private Room' : '#' + item.name;
      nameSpan.title = 'Click to enter ' + item.name;
      div.appendChild(nameSpan);

      const removeBtn = document.createElement("button");
      removeBtn.className = "remove-btn";
      removeBtn.innerText = "×";
      removeBtn.title = "Remove from history";
      removeBtn.onclick = (e) => {
        e.stopPropagation();
        removeFromRoomHistory(item.name);
        displayRoomHistory();
      };
      div.appendChild(removeBtn);

      div.onclick = () => {
        roomname = item.name;
        startChat();
      };

      historyList.appendChild(div);
    });
  }

  function startNameChooser() {
    // Bind event listeners first
    nameForm.addEventListener("submit", event => {
      event.preventDefault();
      username = nameInput.value.trim();
      if (username.length > 0) {
        // Save username to localStorage
        localStorage.setItem('chatUsername', username);
        startRoomChooser();
      }
    });

    nameInput.addEventListener("input", event => {
      if (event.currentTarget.value.length > 32) {
        event.currentTarget.value = event.currentTarget.value.slice(0, 32);
      }
    });

    // Check if username is saved in localStorage
    const savedUsername = localStorage.getItem('chatUsername');
    if (savedUsername) {
      // Pre-fill the username
      nameInput.value = savedUsername;

      // Only auto-submit if we have a room hash in URL
      if (document.location.hash.length > 1) {
        setTimeout(() => {
          nameForm.dispatchEvent(new Event('submit'));
        }, 0);
        return;
      }
    }

    nameInput.focus();
  }

  function startRoomChooser() {
    nameForm.remove();

    if (document.location.hash.length > 1) {
      roomname = document.location.hash.slice(1);
      startChat();
      return;
    }

    // Display room history
    displayRoomHistory();

    roomForm.addEventListener("submit", event => {
      event.preventDefault();
      roomname = roomNameInput.value;
      if (roomname.length > 0) {
        startChat();
      }
    });

    roomNameInput.addEventListener("input", event => {
      if (event.currentTarget.value.length > 32) {
        event.currentTarget.value = event.currentTarget.value.slice(0, 32);
      }
    });

    goPublicButton.addEventListener("click", event => {
      roomname = roomNameInput.value;
      if (roomname.length > 0) {
        startChat();
      }
    });

    goPrivateButton.addEventListener("click", async event => {
      roomNameInput.disabled = true;
      goPublicButton.disabled = true;
      event.currentTarget.disabled = true;

      let response = await fetch("https://" + hostname + "/api/room", { method: "POST" });
      if (!response.ok) {
        alert("something went wrong");
        document.location.reload();
        return;
      }

      roomname = await response.text();
      startChat();
    });

    roomNameInput.focus();
  }

  function startChat() {
    roomForm.remove();

    // Normalize the room name a bit.
    roomname = roomname.replace(/[^a-zA-Z0-9_-]/g, "").replace(/_/g, "-").toLowerCase();

    if (roomname.length > 32 && !roomname.match(/^[0-9a-f]{64}$/)) {
      addSystemMessage("ERROR: Invalid room name.");
      return;
    }

    document.location.hash = "#" + roomname;

    // Save to room history
    addToRoomHistory(roomname);

    // Initialize room info display
    const roomNameDisplay = document.querySelector("#room-name-display");
    const roomNoteTextarea = document.querySelector("#room-note");

    if (roomname.length === 64) {
      roomNameDisplay.textContent = "Private Room";
    } else {
      roomNameDisplay.textContent = "#" + roomname;
    }

    // Load room info from server
    async function loadRoomInfo() {
      try {
        const response = await fetch(`https://${hostname}/api/room/${roomname}/info`);
        if (response.ok) {
          const data = await response.json();
          if (data.note) {
            roomNoteTextarea.value = data.note;
          }
        }
      } catch (err) {
        console.error('Failed to load room info:', err);
      }
    }

    // Save room info to server
    async function saveRoomInfo(note) {
      try {
        await fetch(`https://${hostname}/api/room/${roomname}/info`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ note })
        });
      } catch (err) {
        console.error('Failed to save room info:', err);
      }
    }

    // Load room info on start
    loadRoomInfo();

    // Save room note on change (debounced)
    let saveNoteTimeout;
    roomNoteTextarea.addEventListener("input", () => {
      clearTimeout(saveNoteTimeout);
      saveNoteTimeout = setTimeout(() => {
        saveRoomInfo(roomNoteTextarea.value);
      }, 100);
    });

    // Prevent the room note textarea from losing focus
    roomNoteTextarea.addEventListener("mousedown", (event) => {
      event.stopPropagation();
    });

    roomNoteTextarea.addEventListener("click", (event) => {
      event.stopPropagation();
    });

    // Auto-resize textarea function
    function autoResizeTextarea() {
      chatInput.style.height = 'auto';
      let newHeight = Math.min(chatInput.scrollHeight, 150);
      chatInput.style.height = newHeight + 'px';

      // Adjust file upload button height to match
      let btn = document.querySelector("#file-upload-btn");
      btn.style.height = newHeight + 'px';

      // Adjust hashtag toggle button position
      let hashtagBtn = document.querySelector("#hashtag-toggle");
      hashtagBtn.style.bottom = newHeight + 'px';

      // Adjust chatlog, roster, and hashtag panel bottom position
      chatlog.style.bottom = newHeight + 'px';
      roster.style.bottom = newHeight + 'px';
      if (hashtagPanel) {
        hashtagPanel.style.bottom = newHeight + 'px';
      }
    }

    chatInput.addEventListener("keydown", event => {
      // Enter to send (without shift), Shift+Enter for new line
      if (event.keyCode == 13 && !event.shiftKey) {
        event.preventDefault();
        chatroom.dispatchEvent(new Event('submit'));
        return;
      }

      if (event.keyCode == 38 && chatInput.value === "") {
        // up arrow (only if input is empty)
        chatlog.scrollBy(0, -50);
      } else if (event.keyCode == 40 && chatInput.value === "") {
        // down arrow (only if input is empty)
        chatlog.scrollBy(0, 50);
      } else if (event.keyCode == 33) {
        // page up
        chatlog.scrollBy(0, -chatlog.clientHeight + 50);
      } else if (event.keyCode == 34) {
        // page down
        chatlog.scrollBy(0, chatlog.clientHeight - 50);
      }
    });

    chatroom.addEventListener("submit", event => {
      event.preventDefault();

      if (currentWebSocket) {
        let message = chatInput.value.trim();
        if (message.length > 0) {
          currentWebSocket.send(JSON.stringify({ message: message }));
          chatInput.value = "";
          autoResizeTextarea(); // Reset height after sending

          // Scroll to bottom whenever sending a message.
          chatlog.scrollBy(0, 1e8);
          // Set flag to scroll when we receive our own message back
          isAtBottom = true;
        }
      }
    });

    chatInput.addEventListener("input", event => {
      if (event.currentTarget.value.length > 6000) {
        event.currentTarget.value = event.currentTarget.value.slice(0, 6000);
      }
      autoResizeTextarea();
    });

    chatlog.addEventListener("scroll", event => {
      // Allow 1px tolerance for floating point calculation errors
      isAtBottom = chatlog.scrollTop + chatlog.clientHeight >= chatlog.scrollHeight - 1;
    });

    chatInput.focus();
    autoResizeTextarea(); // Initialize textarea size

    document.body.addEventListener("click", event => {
      // If the user clicked somewhere in the window without selecting any text, focus the chat
      // input. But don't steal focus from textareas or input fields.
      const isTextInput = event.target.tagName === 'TEXTAREA' || event.target.tagName === 'INPUT';
      if (window.getSelection().toString() == "" && !isTextInput) {
        chatInput.focus();
      }
    });

    // Hashtag panel toggle
    hashtagToggle.addEventListener("click", event => {
      event.stopPropagation();
      hashtagPanel.classList.toggle('visible');
      if (hashtagPanel.classList.contains('visible')) {
        loadHashtags();
      }
    });

    // Hashtag panel close button
    document.querySelector("#hashtag-close").addEventListener("click", event => {
      event.stopPropagation();
      hashtagPanel.classList.remove('visible');
    });

    // Load hashtags initially (with a delay to let messages load first)
    setTimeout(() => {
      loadHashtags().then(() => {
        // Check if there's a tag filter in the URL
        const urlParams = new URLSearchParams(window.location.search);
        const tagParam = urlParams.get('tag');
        if (tagParam) {
          // Apply the filter from URL
          window.filterByHashtag(tagParam);
        }
      });
    }, 2000);

    // Upload file function
    async function uploadFile(file, fileName = null) {
      try {
        // Create form data
        const formData = new FormData();
        formData.append("file", file, fileName || file.name);

        // Upload file
        const response = await fetch("https://" + hostname + "/api/room/" + roomname + "/upload", {
          method: "POST",
          body: formData
        });

        if (!response.ok) {
          const error = await response.json();
          addSystemMessage("* Upload failed: " + (error.error || "Unknown error"));
          return false;
        }

        const result = await response.json();

        // Send file message through WebSocket
        if (currentWebSocket) {
          const fileMessage = `FILE:${result.fileUrl}|${result.fileName}|${result.fileType}`;
          currentWebSocket.send(JSON.stringify({ message: fileMessage }));
        }

        return true;
      } catch (err) {
        addSystemMessage("* Upload failed: " + err.message);
        return false;
      }
    }

    // File upload button click handler
    fileUploadBtn.addEventListener("click", event => {
      fileInput.click();
    });

    // File input change handler
    fileInput.addEventListener("change", async event => {
      const file = event.target.files[0];
      if (!file) return;

      // Show uploading message
      addSystemMessage("* Uploading file...");

      const success = await uploadFile(file);
      if (success) {
        // Clear the file input
        fileInput.value = "";
      }
    });

    // Handle paste events for files and text
    chatInput.addEventListener("paste", async event => {
      const items = event.clipboardData?.items;
      if (!items) return;

      // Check for any file (images, documents, etc.)
      for (let item of items) {
        // Skip plain text items (let them paste normally)
        if (item.kind === "file") {
          event.preventDefault();

          const file = item.getAsFile();
          if (!file) continue;

          // Determine file type for display
          const fileType = item.type.startsWith("image/") ? "image" : "file";

          // Show uploading message
          addSystemMessage(`* Uploading pasted ${fileType}...`);

          // Use file name if available, otherwise generate one with timestamp
          let fileName = file.name;
          if (!fileName || fileName === 'image.png' || fileName === 'blob') {
            // Generate filename with timestamp for unnamed files
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const extension = file.type.split('/')[1] || 'bin';
            fileName = `pasted-${timestamp}.${extension}`;
          }

          await uploadFile(file, fileName);

          return; // Stop after processing the first file
        }
      }

      // If no file was found, allow default text paste behavior
    });

    // Detect mobile keyboard appearing and disappearing, and adjust the scroll as appropriate.
    if ('visualViewport' in window) {
      window.visualViewport.addEventListener('resize', function (event) {
        if (isAtBottom) {
          chatlog.scrollBy(0, 1e8);
        }
      });
    }

    join();
  }

  let lastSeenTimestamp = 0;
  let wroteWelcomeMessages = false;
  let isReconnecting = false; // Track if this is a reconnection

  function join() {
    // If we are running via wrangler dev, use ws:
    const wss = document.location.protocol === "http:" ? "ws://" : "wss://";
    let ws = new WebSocket(wss + hostname + "/api/room/" + roomname + "/websocket");
    let rejoined = false;
    let startTime = Date.now();

    let rejoin = async () => {
      if (!rejoined) {
        rejoined = true;
        currentWebSocket = null;
        isReconnecting = true; // Mark as reconnecting

        // Clear the roster.
        while (roster.firstChild) {
          roster.removeChild(roster.firstChild);
        }

        // Don't try to reconnect too rapidly.
        let timeSinceLastJoin = Date.now() - startTime;
        if (timeSinceLastJoin < 3000) {
          // Less than 3 seconds elapsed since last join. Pause a bit.
          await new Promise(resolve => setTimeout(resolve, 3000 - timeSinceLastJoin));
        }

        // OK, reconnect now!
        join();
      }
    }

    ws.addEventListener("open", event => {
      currentWebSocket = ws;

      // Send user info message.
      ws.send(JSON.stringify({ name: username }));
    });

    ws.addEventListener("message", event => {
      let data = JSON.parse(event.data);

      if (data.error) {
        addSystemMessage("* Error: " + data.error);
      } else if (data.joined) {
        let userItem = document.createElement("div");
        userItem.className = "user-item";

        let userName = document.createElement("span");
        userName.innerText = data.joined + (data.joined === username ? " (me)" : "");
        userItem.appendChild(userName);

        // Add logout button only for current user
        if (data.joined === username) {
          let logoutBtn = document.createElement("button");
          logoutBtn.className = "logout-btn";
          logoutBtn.innerText = "×";
          logoutBtn.title = "Logout and change username";
          logoutBtn.onclick = (e) => {
            e.stopPropagation();
            // Clear saved username
            localStorage.removeItem('chatUsername');
            // Close WebSocket
            if (currentWebSocket) {
              currentWebSocket.close();
            }
            // Reload page without hash to start fresh
            window.location.href = window.location.href.split('#')[0];
          };
          userItem.appendChild(logoutBtn);
        }

        roster.appendChild(userItem);
      } else if (data.quit) {
        for (let child of roster.childNodes) {
          const userName = child.querySelector ? child.querySelector("span")?.innerText : child.innerText;
          if (userName == data.quit || userName == data.quit + " (me)") {
            roster.removeChild(child);
            break;
          }
        }
      } else if (data.ready) {
        // All pre-join messages have been delivered.
        if (!wroteWelcomeMessages) {
          wroteWelcomeMessages = true;
          addSystemMessage(
            "* This is a app built with Cloudflare Workers Durable Objects. The source code " +
            "can be found at: https://github.com/bytemain/workers-chat"
          );
          addSystemMessage(
            "* WARNING: Participants in this chat are random people on the internet. " +
            "Names are not authenticated; anyone can pretend to be anyone. The people " +
            "you are chatting with are NOT Cloudflare employees. Chat history is saved."
          );
          if (roomname.length == 64) {
            addSystemMessage(
              "* This is a private room. You can invite someone to the room by sending them the URL."
            );
          } else {
            addSystemMessage(
              "* Welcome to #" + roomname + ". Say hi!"
            );
          }
        } else if (isReconnecting) {
          // Show reconnection success message
          addSystemMessage("* Reconnected successfully.");
          isReconnecting = false;
        }
      } else {
        // A regular chat message.
        if (data.timestamp > lastSeenTimestamp) {
          addChatMessage(data.name, data.message, data.timestamp);
          lastSeenTimestamp = data.timestamp;

          // Scroll to bottom if we were at bottom (includes our own messages)
          if (isAtBottom) {
            chatlog.scrollBy(0, 1e8);
          }
        }
      }
    });

    ws.addEventListener("close", event => {
      console.log("WebSocket closed, reconnecting:", event.code, event.reason);
      if (event.code === 1008 || event.code === 1009) {
        // Username invalid or banned - clear saved username
        localStorage.removeItem('chatUsername');
        shouldReconnect = false; // Don't reconnect
      } else {
        addSystemMessage("* Disconnected from server. Reconnecting...");
        rejoin();
      }
    });
    ws.addEventListener("error", event => {
      console.log("WebSocket error, reconnecting:", event);
      addSystemMessage("* Connection error. Reconnecting...");
      rejoin();
    });
  }

  // Global variable for cross-day pagination
  let lastMsgDateStr = null;

  function addSystemMessage(text) {
    let p = document.createElement("p");
    const sysMsg = document.createElement('system-message');
    sysMsg.setAttribute('message', text);
    p.appendChild(sysMsg);
    chatlog.appendChild(p);
    isAtBottom = true;
    chatlog.scrollBy(0, 1e8);
  }

  function addChatMessage(name, text, ts) {
    // ts: message timestamp (ms)
    let timestamp = ts;
    if (typeof timestamp !== 'number') {
      timestamp = Date.now();
    }
    const date = new Date(timestamp);
    const dateStr = date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0') + '-' + String(date.getDate()).padStart(2, '0');

    // Insert date divider if day changes
    if (lastMsgDateStr !== dateStr) {
      lastMsgDateStr = dateStr;
      const divider = document.createElement('div');
      divider.className = 'date-divider';
      divider.textContent = dateStr;
      divider.style.textAlign = 'center';
      divider.style.color = '#aaa';
      divider.style.fontSize = '0.9em';
      divider.style.margin = '16px 0 8px 0';
      chatlog.appendChild(divider);
    }

    let p = document.createElement("p");

    const chatMessage = document.createElement('chat-message');
    chatMessage.setAttribute('username', name);
    chatMessage.setAttribute('message', text);
    chatMessage.setAttribute('timestamp', String(timestamp));
    p.appendChild(chatMessage);

    // Check if message should be hidden based on current filter
    if (currentHashtagFilter) {
      const hasTag = text.toLowerCase().includes('#' + currentHashtagFilter.toLowerCase());
      if (!hasTag) {
        p.style.display = 'none';
      }
    }

    // Append the new chat line, keeping scroll position if needed
    chatlog.appendChild(p);
    if (isAtBottom) {
      chatlog.scrollBy(0, 1e8);
    }

    // Update hashtags if message contains any
    updateHashtagsOnNewMessage(text);
  }

  // Listen for hash changes to switch rooms
  window.addEventListener('hashchange', () => {
    const newRoomName = document.location.hash.slice(1);
    // Only reload if we're in a different room (not initial room setup)
    if (roomname && newRoomName !== roomname) {
      window.location.reload();
    }
  });

  startNameChooser();
</script>

</html>